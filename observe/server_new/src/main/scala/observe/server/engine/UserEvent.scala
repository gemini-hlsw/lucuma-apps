// Copyright (c) 2016-2025 Association of Universities for Research in Astronomy, Inc. (AURA)
// For license information see LICENSE or https://opensource.org/licenses/BSD-3-Clause

package observe.server.engine

import cats.syntax.all.*
import fs2.Stream
import lucuma.core.enums.Breakpoint
import lucuma.core.model.User
import lucuma.core.model.sequence.Step
import observe.model.ClientId
import observe.model.Observation
import observe.server.EngineState
import observe.server.SeqEvent

import java.time.Instant

/**
 * Events generated by the user.
 */
sealed trait UserEvent[F[_]] extends Product with Serializable {
  def user: Option[User]
  def username: String = user.foldMap(_.displayName)
}

object UserEvent {

  case class Start[F[_]](
    id:       Observation.Id,
    user:     Option[User],
    clientId: ClientId
  ) extends UserEvent[F]
  case class Pause[F[_]](id: Observation.Id, user: Option[User])       extends UserEvent[F]
  case class CancelPause[F[_]](id: Observation.Id, user: Option[User]) extends UserEvent[F]
  case class Breakpoints[F[_]](
    id:    Observation.Id,
    user:  Option[User],
    steps: Set[Step.Id],
    v:     Breakpoint
  ) extends UserEvent[F]
  case class Poll[F[_]](clientId: ClientId)                            extends UserEvent[F] {
    val user: Option[User] = None
  }
  // Generic event to put a function in the main Stream process, which takes an
  // action depending on the current state
  case class GetState[F[_]](f: EngineState[F] => Stream[F, Event[F]])  extends UserEvent[F] {
    val user: Option[User] = None
  }
  // Generic event to put a function in the main Process process, which changes the state
  // depending on the current state
  case class ModifyState[F[_]](f: EngineHandle[F, SeqEvent])           extends UserEvent[F] {
    val user: Option[User] = None
  }
  // Calls a user given function in the main Stream process to stop an Action.
  // It sets the Sequence to be stopped. The user function is called only if the Sequence is running.
  case class ActionStop[F[_]](
    id: Observation.Id,
    f:  EngineState[F] => Stream[F, Event[F]]
  ) extends UserEvent[F] {
    val user: Option[User] = None
  }

  // Uses `cont` to resume execution of a paused Action. If the Action is not paused, it does nothing.
  case class ActionResume[F[_]](id: Observation.Id, i: Int, cont: Stream[F, Result])
      extends UserEvent[F] {
    val user: Option[User] = None
  }

  case class LogDebug[F[_]](msg: String, timestamp: Instant) extends UserEvent[F] {
    val user: Option[User] = None
  }

  case class LogInfo[F[_]](msg: String, timestamp: Instant) extends UserEvent[F] {
    val user: Option[User] = None
  }

  case class LogWarning[F[_]](msg: String, timestamp: Instant) extends UserEvent[F] {
    val user: Option[User] = None
  }

  case class LogError[F[_]](msg: String, timestamp: Instant) extends UserEvent[F] {
    val user: Option[User] = None
  }

  case class Pure[F[_]](ev: SeqEvent) extends UserEvent[F] {
    val user: Option[User] = None
  }

}
