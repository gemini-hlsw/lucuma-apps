// Copyright (c) 2016-2021 Association of Universities for Research in Astronomy, Inc. (AURA)
// For license information see LICENSE or https://opensource.org/licenses/BSD-3-Clause

package explore.constraints

import cats.Endo
import cats.effect.IO
import clue.GraphQLOperation
import clue.annotation.GraphQL
import clue.data.syntax._
import eu.timepit.refined.types.string.NonEmptyString
import explore.implicits._
import explore.model.AirMassRange
import explore.model.ConstraintSetModel
import explore.model.ElevationRange
import explore.model.HourAngleRange
import explore.model.reusability._
import explore.schemas.ObservationDB.Types._
import explore.schemas._
import explore.undo.UndoableView
import explore.undo.Undoer
import lucuma.core.enum._
import lucuma.core.model.ConstraintSet
import lucuma.ui.reusability._
import monocle.Lens

object ConstraintsQueries {
  @GraphQL
  trait ConstraintSetQueryGQL extends GraphQLOperation[ObservationDB] {
    val document = """
      query($id: ConstraintSetId!) {
        constraintSet(constraintSetId: $id) {
          id
          name
          cloudExtinction
          imageQuality
          skyBackground
          waterVapor
          elevationRange {
            type: __typename
            ... on AirMassRange {
              min
              max
            }
            ... on HourAngleRange {
              minHours
              maxHours
            }
          }
        }
      }
      """

    object Data {
      type ConstraintSet = ConstraintSetModel
    }
  }

  /* BEGIN: Generated by clue. DO NOT remove or edit the following code or this comment. */
  // format: off
  object ConstraintSetQuery extends GraphQLOperation[ObservationDB] {
    import ObservationDB.Scalars._
    ignoreUnusedImportScalars()
    import ObservationDB.Enums._
    ignoreUnusedImportEnums()
    import ObservationDB.Types._
    ignoreUnusedImportTypes()
    val document = """
        query($id: ConstraintSetId!) {
          constraintSet(constraintSetId: $id) {
            id
            name
            cloudExtinction
            imageQuality
            skyBackground
            waterVapor
            elevationRange {
              type: __typename
              ... on AirMassRange {
                min
                max
              }
              ... on HourAngleRange {
                minHours
                maxHours
              }
            }
          }
        }
        """
    object Data {
      type ConstraintSet = ConstraintSetModel
      implicit val constraintSet: monocle.Lens[Data, Option[Data.ConstraintSet]] = monocle.macros.GenLens[Data](_.constraintSet)
      implicit val eqData: cats.Eq[Data] = cats.Eq.fromUniversalEquals
      implicit val showData: cats.Show[Data] = cats.Show.fromToString
      implicit val reuseData: japgolly.scalajs.react.Reusability[Data] = {
        import japgolly.scalajs.react.Reusability
        japgolly.scalajs.react.Reusability.derive
      }
      implicit val jsonDecoderData: io.circe.Decoder[Data] = io.circe.generic.semiauto.deriveDecoder[Data]
    }
    case class Variables(val id: ConstraintSetId)
    object Variables {
      implicit val id: monocle.Lens[Variables, ConstraintSetId] = monocle.macros.GenLens[Variables](_.id)
      implicit val eqVariables: cats.Eq[Variables] = cats.Eq.fromUniversalEquals
      implicit val showVariables: cats.Show[Variables] = cats.Show.fromToString
      implicit val jsonEncoderVariables: io.circe.Encoder[Variables] = io.circe.generic.semiauto.deriveEncoder[Variables].mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class Data(val constraintSet: Option[Data.ConstraintSet] = None)
    val varEncoder: io.circe.Encoder[Variables] = Variables.jsonEncoderVariables
    val dataDecoder: io.circe.Decoder[Data] = Data.jsonDecoderData
    def query[F[_]](id: ConstraintSetId)(implicit client: clue.TransactionalClient[F, ObservationDB]) = client.request(this)(Variables(id))
  }
  // format: on
  /* END: Generated by clue. Will be replaced when regenerating. */

  @GraphQL
  trait ConstraintSetEditSubscriptionGQL extends GraphQLOperation[ObservationDB] {
    val document = """
      subscription($id: ConstraintSetId!) {
        constraintSetEdit(constraintSetId: $id) {
          id
        }
      }
    """
  }

  /* BEGIN: Generated by clue. DO NOT remove or edit the following code or this comment. */
  // format: off
  object ConstraintSetEditSubscription extends GraphQLOperation[ObservationDB] {
    import ObservationDB.Scalars._
    ignoreUnusedImportScalars()
    import ObservationDB.Enums._
    ignoreUnusedImportEnums()
    import ObservationDB.Types._
    ignoreUnusedImportTypes()
    val document = """
        subscription($id: ConstraintSetId!) {
          constraintSetEdit(constraintSetId: $id) {
            id
          }
        }
      """
    case class Variables(val id: ConstraintSetId)
    object Variables {
      implicit val id: monocle.Lens[Variables, ConstraintSetId] = monocle.macros.GenLens[Variables](_.id)
      implicit val eqVariables: cats.Eq[Variables] = cats.Eq.fromUniversalEquals
      implicit val showVariables: cats.Show[Variables] = cats.Show.fromToString
      implicit val jsonEncoderVariables: io.circe.Encoder[Variables] = io.circe.generic.semiauto.deriveEncoder[Variables].mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class Data(val constraintSetEdit: Data.ConstraintSetEdit)
    object Data {
      case class ConstraintSetEdit(val id: Long)
      object ConstraintSetEdit {
        implicit val id: monocle.Lens[Data.ConstraintSetEdit, Long] = monocle.macros.GenLens[Data.ConstraintSetEdit](_.id)
        implicit val eqConstraintSetEdit: cats.Eq[Data.ConstraintSetEdit] = cats.Eq.fromUniversalEquals
        implicit val showConstraintSetEdit: cats.Show[Data.ConstraintSetEdit] = cats.Show.fromToString
        implicit val reuseConstraintSetEdit: japgolly.scalajs.react.Reusability[Data.ConstraintSetEdit] = {
          import japgolly.scalajs.react.Reusability
          japgolly.scalajs.react.Reusability.derive
        }
        implicit val jsonDecoderConstraintSetEdit: io.circe.Decoder[Data.ConstraintSetEdit] = io.circe.generic.semiauto.deriveDecoder[Data.ConstraintSetEdit]
      }
      implicit val constraintSetEdit: monocle.Lens[Data, Data.ConstraintSetEdit] = monocle.macros.GenLens[Data](_.constraintSetEdit)
      implicit val eqData: cats.Eq[Data] = cats.Eq.fromUniversalEquals
      implicit val showData: cats.Show[Data] = cats.Show.fromToString
      implicit val reuseData: japgolly.scalajs.react.Reusability[Data] = {
        import japgolly.scalajs.react.Reusability
        japgolly.scalajs.react.Reusability.derive
      }
      implicit val jsonDecoderData: io.circe.Decoder[Data] = io.circe.generic.semiauto.deriveDecoder[Data]
    }
    val varEncoder: io.circe.Encoder[Variables] = Variables.jsonEncoderVariables
    val dataDecoder: io.circe.Decoder[Data] = Data.jsonDecoderData
    def subscribe[F[_]](id: ConstraintSetId)(implicit client: clue.StreamingClient[F, ObservationDB]) = client.subscribe(this)(Variables(id))
  }
  // format: on
  /* END: Generated by clue. Will be replaced when regenerating. */

  @GraphQL
  trait MutationGQL extends GraphQLOperation[ObservationDB] {
    val document = """
      mutation ($input: EditConstraintSetInput!){
        updateConstraintSet(input: $input) {
          id
        }
      }
    """
  }

  /* BEGIN: Generated by clue. DO NOT remove or edit the following code or this comment. */
  // format: off
  object Mutation extends GraphQLOperation[ObservationDB] {
    import ObservationDB.Scalars._
    ignoreUnusedImportScalars()
    import ObservationDB.Enums._
    ignoreUnusedImportEnums()
    import ObservationDB.Types._
    ignoreUnusedImportTypes()
    val document = """
        mutation ($input: EditConstraintSetInput!){
          updateConstraintSet(input: $input) {
            id
          }
        }
      """
    case class Variables(val input: EditConstraintSetInput)
    object Variables {
      implicit val input: monocle.Lens[Variables, EditConstraintSetInput] = monocle.macros.GenLens[Variables](_.input)
      implicit val eqVariables: cats.Eq[Variables] = cats.Eq.fromUniversalEquals
      implicit val showVariables: cats.Show[Variables] = cats.Show.fromToString
      implicit val jsonEncoderVariables: io.circe.Encoder[Variables] = io.circe.generic.semiauto.deriveEncoder[Variables].mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class Data(val updateConstraintSet: Data.UpdateConstraintSet)
    object Data {
      case class UpdateConstraintSet(val id: ConstraintSetId)
      object UpdateConstraintSet {
        implicit val id: monocle.Lens[Data.UpdateConstraintSet, ConstraintSetId] = monocle.macros.GenLens[Data.UpdateConstraintSet](_.id)
        implicit val eqUpdateConstraintSet: cats.Eq[Data.UpdateConstraintSet] = cats.Eq.fromUniversalEquals
        implicit val showUpdateConstraintSet: cats.Show[Data.UpdateConstraintSet] = cats.Show.fromToString
        implicit val reuseUpdateConstraintSet: japgolly.scalajs.react.Reusability[Data.UpdateConstraintSet] = {
          import japgolly.scalajs.react.Reusability
          japgolly.scalajs.react.Reusability.derive
        }
        implicit val jsonDecoderUpdateConstraintSet: io.circe.Decoder[Data.UpdateConstraintSet] = io.circe.generic.semiauto.deriveDecoder[Data.UpdateConstraintSet]
      }
      implicit val updateConstraintSet: monocle.Lens[Data, Data.UpdateConstraintSet] = monocle.macros.GenLens[Data](_.updateConstraintSet)
      implicit val eqData: cats.Eq[Data] = cats.Eq.fromUniversalEquals
      implicit val showData: cats.Show[Data] = cats.Show.fromToString
      implicit val reuseData: japgolly.scalajs.react.Reusability[Data] = {
        import japgolly.scalajs.react.Reusability
        japgolly.scalajs.react.Reusability.derive
      }
      implicit val jsonDecoderData: io.circe.Decoder[Data] = io.circe.generic.semiauto.deriveDecoder[Data]
    }
    val varEncoder: io.circe.Encoder[Variables] = Variables.jsonEncoderVariables
    val dataDecoder: io.circe.Decoder[Data] = Data.jsonDecoderData
    def execute[F[_]](input: EditConstraintSetInput)(implicit client: clue.TransactionalClient[F, ObservationDB]) = client.request(this)(Variables(input))
  }
  // format: on
  /* END: Generated by clue. Will be replaced when regenerating. */

  case class UndoView(
    id:           ConstraintSet.Id,
    view:         View[ConstraintSetModel],
    setter:       Undoer.Setter[IO, ConstraintSetModel]
  )(implicit ctx: AppContextIO) {
    private val undoableView = UndoableView(view, setter)

    def apply[A](
      modelGet:  ConstraintSetModel => A,
      modelMod:  (A => A) => ConstraintSetModel => ConstraintSetModel,
      remoteSet: A => EditConstraintSetInput => EditConstraintSetInput
    ): View[A] =
      undoableView.apply(
        modelGet,
        modelMod,
        value => Mutation.execute(remoteSet(value)(EditConstraintSetInput(id))).void
      )

    def apply[A](
      lens:      Lens[ConstraintSetModel, A],
      remoteSet: A => EditConstraintSetInput => EditConstraintSetInput
    ): View[A] =
      apply(lens.get, lens.modify, remoteSet)

  }

  object UpdateConstraintSet {
    def name(n: NonEmptyString): Endo[EditConstraintSetInput] =
      EditConstraintSetInput.name.set(n.assign)

    def imageQuality(iq: ImageQuality): Endo[EditConstraintSetInput] =
      EditConstraintSetInput.imageQuality.set(iq.assign)

    def cloudExtinction(ce: CloudExtinction): Endo[EditConstraintSetInput] =
      EditConstraintSetInput.cloudExtinction.set(ce.assign)

    def skyBackground(sb: SkyBackground): Endo[EditConstraintSetInput] =
      EditConstraintSetInput.skyBackground.set(sb.assign)

    def waterVapor(wv: WaterVapor): Endo[EditConstraintSetInput] =
      EditConstraintSetInput.waterVapor.set(wv.assign)

    def elevationRange(er: ElevationRange): Endo[EditConstraintSetInput] = {
      val createER: CreateElevationRangeInput = er match {
        case AirMassRange(min, max)   =>
          CreateElevationRangeInput(airmassRange =
            CreateAirmassRangeInput(min = min.value, max = max.value).assign
          )
        case HourAngleRange(min, max) =>
          CreateElevationRangeInput(hourAngleRange =
            CreateHourAngleRangeInput(minHours = min.value, maxHours = max.value).assign
          )
      }
      CreateElevationRangeInput()
      EditConstraintSetInput.elevationRange.set(createER.assign)
    }
  }
}
