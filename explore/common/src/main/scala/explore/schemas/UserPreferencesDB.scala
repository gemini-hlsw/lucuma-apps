package explore.schemas

import clue.annotation.GraphQLSchema
import lucuma.core.model.User
import explore.model.ResizableSection

@GraphQLSchema
object UserPreferencesDBGQL {
  object Scalars {
    type UserId         = User.Id
    type ResizableArea  = String
    type BreakpointName = String
    type GridLayoutArea = String
    type Bigint         = Long
  }

  object Types {
    final case class WidthUpsertInput(user: User.Id, section: ResizableSection, width: Int)
  }
}

/* BEGIN: Generated by clue. DO NOT remove or edit the following code or this comment. */
sealed trait UserPreferencesDB
object UserPreferencesDB {
  object Scalars {
    type UserId         = User.Id
    type ResizableArea  = String
    type BreakpointName = String
    type GridLayoutArea = String
    type Bigint         = Long
    def ignoreUnusedImportScalars(): Unit = ()
  }
  object Types   {
    import Scalars._
    ignoreUnusedImportScalars()
    import Enums._
    ignoreUnusedImportEnums()
    def ignoreUnusedImportTypes(): Unit = ()
    final case class WidthUpsertInput(user: User.Id, section: ResizableSection, width: Int)
    case class BigintComparisonExp(
      val _eq:      clue.data.Input[Bigint] = clue.data.Ignore,
      val _gt:      clue.data.Input[Bigint] = clue.data.Ignore,
      val _gte:     clue.data.Input[Bigint] = clue.data.Ignore,
      val _in:      clue.data.Input[List[Bigint]] = clue.data.Ignore,
      val _is_null: clue.data.Input[Boolean] = clue.data.Ignore,
      val _lt:      clue.data.Input[Bigint] = clue.data.Ignore,
      val _lte:     clue.data.Input[Bigint] = clue.data.Ignore,
      val _neq:     clue.data.Input[Bigint] = clue.data.Ignore,
      val _nin:     clue.data.Input[List[Bigint]] = clue.data.Ignore
    )
    object BigintComparisonExp {
      implicit val _eq: monocle.Lens[BigintComparisonExp, clue.data.Input[Bigint]]        =
        monocle.macros.GenLens[BigintComparisonExp](_._eq)
      implicit val _gt: monocle.Lens[BigintComparisonExp, clue.data.Input[Bigint]]        =
        monocle.macros.GenLens[BigintComparisonExp](_._gt)
      implicit val _gte: monocle.Lens[BigintComparisonExp, clue.data.Input[Bigint]]       =
        monocle.macros.GenLens[BigintComparisonExp](_._gte)
      implicit val _in: monocle.Lens[BigintComparisonExp, clue.data.Input[List[Bigint]]]  =
        monocle.macros.GenLens[BigintComparisonExp](_._in)
      implicit val _is_null: monocle.Lens[BigintComparisonExp, clue.data.Input[Boolean]]  =
        monocle.macros.GenLens[BigintComparisonExp](_._is_null)
      implicit val _lt: monocle.Lens[BigintComparisonExp, clue.data.Input[Bigint]]        =
        monocle.macros.GenLens[BigintComparisonExp](_._lt)
      implicit val _lte: monocle.Lens[BigintComparisonExp, clue.data.Input[Bigint]]       =
        monocle.macros.GenLens[BigintComparisonExp](_._lte)
      implicit val _neq: monocle.Lens[BigintComparisonExp, clue.data.Input[Bigint]]       =
        monocle.macros.GenLens[BigintComparisonExp](_._neq)
      implicit val _nin: monocle.Lens[BigintComparisonExp, clue.data.Input[List[Bigint]]] =
        monocle.macros.GenLens[BigintComparisonExp](_._nin)
      implicit val eqBigintComparisonExp: cats.Eq[BigintComparisonExp]                    = cats.Eq.fromUniversalEquals
      implicit val showBigintComparisonExp: cats.Show[BigintComparisonExp]                = cats.Show.fromToString
      implicit val jsonEncoderBigintComparisonExp: io.circe.Encoder[BigintComparisonExp]  =
        io.circe.generic.semiauto
          .deriveEncoder[BigintComparisonExp]
          .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class BreakpointNameComparisonExp(
      val _eq:      clue.data.Input[BreakpointName] = clue.data.Ignore,
      val _gt:      clue.data.Input[BreakpointName] = clue.data.Ignore,
      val _gte:     clue.data.Input[BreakpointName] = clue.data.Ignore,
      val _in:      clue.data.Input[List[BreakpointName]] = clue.data.Ignore,
      val _is_null: clue.data.Input[Boolean] = clue.data.Ignore,
      val _lt:      clue.data.Input[BreakpointName] = clue.data.Ignore,
      val _lte:     clue.data.Input[BreakpointName] = clue.data.Ignore,
      val _neq:     clue.data.Input[BreakpointName] = clue.data.Ignore,
      val _nin:     clue.data.Input[List[BreakpointName]] = clue.data.Ignore
    )
    object BreakpointNameComparisonExp {
      implicit val _eq: monocle.Lens[BreakpointNameComparisonExp, clue.data.Input[BreakpointName]] =
        monocle.macros.GenLens[BreakpointNameComparisonExp](_._eq)
      implicit val _gt: monocle.Lens[BreakpointNameComparisonExp, clue.data.Input[BreakpointName]] =
        monocle.macros.GenLens[BreakpointNameComparisonExp](_._gt)
      implicit val _gte
        : monocle.Lens[BreakpointNameComparisonExp, clue.data.Input[BreakpointName]]               =
        monocle.macros.GenLens[BreakpointNameComparisonExp](_._gte)
      implicit val _in
        : monocle.Lens[BreakpointNameComparisonExp, clue.data.Input[List[BreakpointName]]]         =
        monocle.macros.GenLens[BreakpointNameComparisonExp](_._in)
      implicit val _is_null: monocle.Lens[BreakpointNameComparisonExp, clue.data.Input[Boolean]]   =
        monocle.macros.GenLens[BreakpointNameComparisonExp](_._is_null)
      implicit val _lt: monocle.Lens[BreakpointNameComparisonExp, clue.data.Input[BreakpointName]] =
        monocle.macros.GenLens[BreakpointNameComparisonExp](_._lt)
      implicit val _lte
        : monocle.Lens[BreakpointNameComparisonExp, clue.data.Input[BreakpointName]]               =
        monocle.macros.GenLens[BreakpointNameComparisonExp](_._lte)
      implicit val _neq
        : monocle.Lens[BreakpointNameComparisonExp, clue.data.Input[BreakpointName]]               =
        monocle.macros.GenLens[BreakpointNameComparisonExp](_._neq)
      implicit val _nin
        : monocle.Lens[BreakpointNameComparisonExp, clue.data.Input[List[BreakpointName]]]         =
        monocle.macros.GenLens[BreakpointNameComparisonExp](_._nin)
      implicit val eqBreakpointNameComparisonExp: cats.Eq[BreakpointNameComparisonExp]             =
        cats.Eq.fromUniversalEquals
      implicit val showBreakpointNameComparisonExp: cats.Show[BreakpointNameComparisonExp]         =
        cats.Show.fromToString
      implicit val jsonEncoderBreakpointNameComparisonExp
        : io.circe.Encoder[BreakpointNameComparisonExp]                                            = io.circe.generic.semiauto
        .deriveEncoder[BreakpointNameComparisonExp]
        .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class ExploreResizableWidthAggregateOrderBy(
      val avg:         clue.data.Input[ExploreResizableWidthAvgOrderBy] = clue.data.Ignore,
      val count:       clue.data.Input[OrderBy] = clue.data.Ignore,
      val max:         clue.data.Input[ExploreResizableWidthMaxOrderBy] = clue.data.Ignore,
      val min:         clue.data.Input[ExploreResizableWidthMinOrderBy] = clue.data.Ignore,
      val stddev:      clue.data.Input[ExploreResizableWidthStddevOrderBy] = clue.data.Ignore,
      val stddev_pop:  clue.data.Input[ExploreResizableWidthStddevPopOrderBy] = clue.data.Ignore,
      val stddev_samp: clue.data.Input[ExploreResizableWidthStddevSampOrderBy] = clue.data.Ignore,
      val sum:         clue.data.Input[ExploreResizableWidthSumOrderBy] = clue.data.Ignore,
      val var_pop:     clue.data.Input[ExploreResizableWidthVarPopOrderBy] = clue.data.Ignore,
      val var_samp:    clue.data.Input[ExploreResizableWidthVarSampOrderBy] = clue.data.Ignore,
      val variance:    clue.data.Input[ExploreResizableWidthVarianceOrderBy] = clue.data.Ignore
    )
    object ExploreResizableWidthAggregateOrderBy {
      implicit val avg: monocle.Lens[ExploreResizableWidthAggregateOrderBy, clue.data.Input[
        ExploreResizableWidthAvgOrderBy
      ]]                                                                                = monocle.macros.GenLens[ExploreResizableWidthAggregateOrderBy](_.avg)
      implicit val count
        : monocle.Lens[ExploreResizableWidthAggregateOrderBy, clue.data.Input[OrderBy]] =
        monocle.macros.GenLens[ExploreResizableWidthAggregateOrderBy](_.count)
      implicit val max: monocle.Lens[ExploreResizableWidthAggregateOrderBy, clue.data.Input[
        ExploreResizableWidthMaxOrderBy
      ]]                                                                                = monocle.macros.GenLens[ExploreResizableWidthAggregateOrderBy](_.max)
      implicit val min: monocle.Lens[ExploreResizableWidthAggregateOrderBy, clue.data.Input[
        ExploreResizableWidthMinOrderBy
      ]]                                                                                = monocle.macros.GenLens[ExploreResizableWidthAggregateOrderBy](_.min)
      implicit val stddev: monocle.Lens[ExploreResizableWidthAggregateOrderBy, clue.data.Input[
        ExploreResizableWidthStddevOrderBy
      ]]                                                                                = monocle.macros.GenLens[ExploreResizableWidthAggregateOrderBy](_.stddev)
      implicit val stddev_pop: monocle.Lens[ExploreResizableWidthAggregateOrderBy, clue.data.Input[
        ExploreResizableWidthStddevPopOrderBy
      ]]                                                                                = monocle.macros.GenLens[ExploreResizableWidthAggregateOrderBy](_.stddev_pop)
      implicit val stddev_samp: monocle.Lens[ExploreResizableWidthAggregateOrderBy, clue.data.Input[
        ExploreResizableWidthStddevSampOrderBy
      ]]                                                                                = monocle.macros.GenLens[ExploreResizableWidthAggregateOrderBy](_.stddev_samp)
      implicit val sum: monocle.Lens[ExploreResizableWidthAggregateOrderBy, clue.data.Input[
        ExploreResizableWidthSumOrderBy
      ]]                                                                                = monocle.macros.GenLens[ExploreResizableWidthAggregateOrderBy](_.sum)
      implicit val var_pop: monocle.Lens[ExploreResizableWidthAggregateOrderBy, clue.data.Input[
        ExploreResizableWidthVarPopOrderBy
      ]]                                                                                = monocle.macros.GenLens[ExploreResizableWidthAggregateOrderBy](_.var_pop)
      implicit val var_samp: monocle.Lens[ExploreResizableWidthAggregateOrderBy, clue.data.Input[
        ExploreResizableWidthVarSampOrderBy
      ]]                                                                                = monocle.macros.GenLens[ExploreResizableWidthAggregateOrderBy](_.var_samp)
      implicit val variance: monocle.Lens[ExploreResizableWidthAggregateOrderBy, clue.data.Input[
        ExploreResizableWidthVarianceOrderBy
      ]]                                                                                = monocle.macros.GenLens[ExploreResizableWidthAggregateOrderBy](_.variance)
      implicit val eqExploreResizableWidthAggregateOrderBy
        : cats.Eq[ExploreResizableWidthAggregateOrderBy]                                = cats.Eq.fromUniversalEquals
      implicit val showExploreResizableWidthAggregateOrderBy
        : cats.Show[ExploreResizableWidthAggregateOrderBy]                              = cats.Show.fromToString
      implicit val jsonEncoderExploreResizableWidthAggregateOrderBy
        : io.circe.Encoder[ExploreResizableWidthAggregateOrderBy]                       = io.circe.generic.semiauto
        .deriveEncoder[ExploreResizableWidthAggregateOrderBy]
        .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class ExploreResizableWidthArrRelInsertInput(
      val data:        List[ExploreResizableWidthInsertInput],
      val on_conflict: clue.data.Input[ExploreResizableWidthOnConflict] = clue.data.Ignore
    )
    object ExploreResizableWidthArrRelInsertInput {
      implicit val data: monocle.Lens[ExploreResizableWidthArrRelInsertInput, List[
        ExploreResizableWidthInsertInput
      ]]                                                           = monocle.macros.GenLens[ExploreResizableWidthArrRelInsertInput](_.data)
      implicit val on_conflict: monocle.Lens[
        ExploreResizableWidthArrRelInsertInput,
        clue.data.Input[ExploreResizableWidthOnConflict]
      ]                                                            = monocle.macros.GenLens[ExploreResizableWidthArrRelInsertInput](_.on_conflict)
      implicit val eqExploreResizableWidthArrRelInsertInput
        : cats.Eq[ExploreResizableWidthArrRelInsertInput]          = cats.Eq.fromUniversalEquals
      implicit val showExploreResizableWidthArrRelInsertInput
        : cats.Show[ExploreResizableWidthArrRelInsertInput]        = cats.Show.fromToString
      implicit val jsonEncoderExploreResizableWidthArrRelInsertInput
        : io.circe.Encoder[ExploreResizableWidthArrRelInsertInput] = io.circe.generic.semiauto
        .deriveEncoder[ExploreResizableWidthArrRelInsertInput]
        .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class ExploreResizableWidthAvgOrderBy(
      val width: clue.data.Input[OrderBy] = clue.data.Ignore
    )
    object ExploreResizableWidthAvgOrderBy {
      implicit val width: monocle.Lens[ExploreResizableWidthAvgOrderBy, clue.data.Input[OrderBy]]  =
        monocle.macros.GenLens[ExploreResizableWidthAvgOrderBy](_.width)
      implicit val eqExploreResizableWidthAvgOrderBy: cats.Eq[ExploreResizableWidthAvgOrderBy]     =
        cats.Eq.fromUniversalEquals
      implicit val showExploreResizableWidthAvgOrderBy: cats.Show[ExploreResizableWidthAvgOrderBy] =
        cats.Show.fromToString
      implicit val jsonEncoderExploreResizableWidthAvgOrderBy
        : io.circe.Encoder[ExploreResizableWidthAvgOrderBy]                                        = io.circe.generic.semiauto
        .deriveEncoder[ExploreResizableWidthAvgOrderBy]
        .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class ExploreResizableWidthBoolExp(
      val _and:    clue.data.Input[List[clue.data.Input[ExploreResizableWidthBoolExp]]] =
        clue.data.Ignore,
      val _not:    clue.data.Input[ExploreResizableWidthBoolExp] = clue.data.Ignore,
      val _or:     clue.data.Input[List[clue.data.Input[ExploreResizableWidthBoolExp]]] =
        clue.data.Ignore,
      val section: clue.data.Input[ResizableAreaComparisonExp] = clue.data.Ignore,
      val user_id: clue.data.Input[StringComparisonExp] = clue.data.Ignore,
      val width:   clue.data.Input[IntComparisonExp] = clue.data.Ignore
    )
    object ExploreResizableWidthBoolExp {
      implicit val _and: monocle.Lens[ExploreResizableWidthBoolExp, clue.data.Input[List[
        clue.data.Input[ExploreResizableWidthBoolExp]
      ]]]                                                                                         = monocle.macros.GenLens[ExploreResizableWidthBoolExp](_._and)
      implicit val _not: monocle.Lens[ExploreResizableWidthBoolExp, clue.data.Input[
        ExploreResizableWidthBoolExp
      ]]                                                                                          = monocle.macros.GenLens[ExploreResizableWidthBoolExp](_._not)
      implicit val _or: monocle.Lens[ExploreResizableWidthBoolExp, clue.data.Input[List[
        clue.data.Input[ExploreResizableWidthBoolExp]
      ]]]                                                                                         = monocle.macros.GenLens[ExploreResizableWidthBoolExp](_._or)
      implicit val section
        : monocle.Lens[ExploreResizableWidthBoolExp, clue.data.Input[ResizableAreaComparisonExp]] =
        monocle.macros.GenLens[ExploreResizableWidthBoolExp](_.section)
      implicit val user_id
        : monocle.Lens[ExploreResizableWidthBoolExp, clue.data.Input[StringComparisonExp]]        =
        monocle.macros.GenLens[ExploreResizableWidthBoolExp](_.user_id)
      implicit val width
        : monocle.Lens[ExploreResizableWidthBoolExp, clue.data.Input[IntComparisonExp]]           =
        monocle.macros.GenLens[ExploreResizableWidthBoolExp](_.width)
      implicit val eqExploreResizableWidthBoolExp: cats.Eq[ExploreResizableWidthBoolExp]          =
        cats.Eq.fromUniversalEquals
      implicit val showExploreResizableWidthBoolExp: cats.Show[ExploreResizableWidthBoolExp]      =
        cats.Show.fromToString
      implicit val jsonEncoderExploreResizableWidthBoolExp
        : io.circe.Encoder[ExploreResizableWidthBoolExp]                                          = io.circe.generic.semiauto
        .deriveEncoder[ExploreResizableWidthBoolExp]
        .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class ExploreResizableWidthIncInput(val width: clue.data.Input[Int] = clue.data.Ignore)
    object ExploreResizableWidthIncInput {
      implicit val width: monocle.Lens[ExploreResizableWidthIncInput, clue.data.Input[Int]]    =
        monocle.macros.GenLens[ExploreResizableWidthIncInput](_.width)
      implicit val eqExploreResizableWidthIncInput: cats.Eq[ExploreResizableWidthIncInput]     =
        cats.Eq.fromUniversalEquals
      implicit val showExploreResizableWidthIncInput: cats.Show[ExploreResizableWidthIncInput] =
        cats.Show.fromToString
      implicit val jsonEncoderExploreResizableWidthIncInput
        : io.circe.Encoder[ExploreResizableWidthIncInput]                                      = io.circe.generic.semiauto
        .deriveEncoder[ExploreResizableWidthIncInput]
        .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class ExploreResizableWidthInsertInput(
      val section: clue.data.Input[ResizableArea] = clue.data.Ignore,
      val user_id: clue.data.Input[String] = clue.data.Ignore,
      val width:   clue.data.Input[Int] = clue.data.Ignore
    )
    object ExploreResizableWidthInsertInput {
      implicit val section
        : monocle.Lens[ExploreResizableWidthInsertInput, clue.data.Input[ResizableArea]]         =
        monocle.macros.GenLens[ExploreResizableWidthInsertInput](_.section)
      implicit val user_id
        : monocle.Lens[ExploreResizableWidthInsertInput, clue.data.Input[String]]                =
        monocle.macros.GenLens[ExploreResizableWidthInsertInput](_.user_id)
      implicit val width: monocle.Lens[ExploreResizableWidthInsertInput, clue.data.Input[Int]]   =
        monocle.macros.GenLens[ExploreResizableWidthInsertInput](_.width)
      implicit val eqExploreResizableWidthInsertInput: cats.Eq[ExploreResizableWidthInsertInput] =
        cats.Eq.fromUniversalEquals
      implicit val showExploreResizableWidthInsertInput
        : cats.Show[ExploreResizableWidthInsertInput]                                            = cats.Show.fromToString
      implicit val jsonEncoderExploreResizableWidthInsertInput
        : io.circe.Encoder[ExploreResizableWidthInsertInput]                                     = io.circe.generic.semiauto
        .deriveEncoder[ExploreResizableWidthInsertInput]
        .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class ExploreResizableWidthMaxOrderBy(
      val user_id: clue.data.Input[OrderBy] = clue.data.Ignore,
      val width:   clue.data.Input[OrderBy] = clue.data.Ignore
    )
    object ExploreResizableWidthMaxOrderBy {
      implicit val user_id
        : monocle.Lens[ExploreResizableWidthMaxOrderBy, clue.data.Input[OrderBy]]                  =
        monocle.macros.GenLens[ExploreResizableWidthMaxOrderBy](_.user_id)
      implicit val width: monocle.Lens[ExploreResizableWidthMaxOrderBy, clue.data.Input[OrderBy]]  =
        monocle.macros.GenLens[ExploreResizableWidthMaxOrderBy](_.width)
      implicit val eqExploreResizableWidthMaxOrderBy: cats.Eq[ExploreResizableWidthMaxOrderBy]     =
        cats.Eq.fromUniversalEquals
      implicit val showExploreResizableWidthMaxOrderBy: cats.Show[ExploreResizableWidthMaxOrderBy] =
        cats.Show.fromToString
      implicit val jsonEncoderExploreResizableWidthMaxOrderBy
        : io.circe.Encoder[ExploreResizableWidthMaxOrderBy]                                        = io.circe.generic.semiauto
        .deriveEncoder[ExploreResizableWidthMaxOrderBy]
        .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class ExploreResizableWidthMinOrderBy(
      val user_id: clue.data.Input[OrderBy] = clue.data.Ignore,
      val width:   clue.data.Input[OrderBy] = clue.data.Ignore
    )
    object ExploreResizableWidthMinOrderBy {
      implicit val user_id
        : monocle.Lens[ExploreResizableWidthMinOrderBy, clue.data.Input[OrderBy]]                  =
        monocle.macros.GenLens[ExploreResizableWidthMinOrderBy](_.user_id)
      implicit val width: monocle.Lens[ExploreResizableWidthMinOrderBy, clue.data.Input[OrderBy]]  =
        monocle.macros.GenLens[ExploreResizableWidthMinOrderBy](_.width)
      implicit val eqExploreResizableWidthMinOrderBy: cats.Eq[ExploreResizableWidthMinOrderBy]     =
        cats.Eq.fromUniversalEquals
      implicit val showExploreResizableWidthMinOrderBy: cats.Show[ExploreResizableWidthMinOrderBy] =
        cats.Show.fromToString
      implicit val jsonEncoderExploreResizableWidthMinOrderBy
        : io.circe.Encoder[ExploreResizableWidthMinOrderBy]                                        = io.circe.generic.semiauto
        .deriveEncoder[ExploreResizableWidthMinOrderBy]
        .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class ExploreResizableWidthObjRelInsertInput(
      val data:        ExploreResizableWidthInsertInput,
      val on_conflict: clue.data.Input[ExploreResizableWidthOnConflict] = clue.data.Ignore
    )
    object ExploreResizableWidthObjRelInsertInput {
      implicit val data
        : monocle.Lens[ExploreResizableWidthObjRelInsertInput, ExploreResizableWidthInsertInput] =
        monocle.macros.GenLens[ExploreResizableWidthObjRelInsertInput](_.data)
      implicit val on_conflict: monocle.Lens[
        ExploreResizableWidthObjRelInsertInput,
        clue.data.Input[ExploreResizableWidthOnConflict]
      ]                                                                                          = monocle.macros.GenLens[ExploreResizableWidthObjRelInsertInput](_.on_conflict)
      implicit val eqExploreResizableWidthObjRelInsertInput
        : cats.Eq[ExploreResizableWidthObjRelInsertInput]                                        = cats.Eq.fromUniversalEquals
      implicit val showExploreResizableWidthObjRelInsertInput
        : cats.Show[ExploreResizableWidthObjRelInsertInput]                                      = cats.Show.fromToString
      implicit val jsonEncoderExploreResizableWidthObjRelInsertInput
        : io.circe.Encoder[ExploreResizableWidthObjRelInsertInput]                               = io.circe.generic.semiauto
        .deriveEncoder[ExploreResizableWidthObjRelInsertInput]
        .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class ExploreResizableWidthOnConflict(
      val constraint:     ExploreResizableWidthConstraint,
      val update_columns: List[ExploreResizableWidthUpdateColumn],
      val where:          clue.data.Input[ExploreResizableWidthBoolExp] = clue.data.Ignore
    )
    object ExploreResizableWidthOnConflict {
      implicit val constraint
        : monocle.Lens[ExploreResizableWidthOnConflict, ExploreResizableWidthConstraint]           =
        monocle.macros.GenLens[ExploreResizableWidthOnConflict](_.constraint)
      implicit val update_columns
        : monocle.Lens[ExploreResizableWidthOnConflict, List[ExploreResizableWidthUpdateColumn]]   =
        monocle.macros.GenLens[ExploreResizableWidthOnConflict](_.update_columns)
      implicit val where: monocle.Lens[ExploreResizableWidthOnConflict, clue.data.Input[
        ExploreResizableWidthBoolExp
      ]]                                                                                           = monocle.macros.GenLens[ExploreResizableWidthOnConflict](_.where)
      implicit val eqExploreResizableWidthOnConflict: cats.Eq[ExploreResizableWidthOnConflict]     =
        cats.Eq.fromUniversalEquals
      implicit val showExploreResizableWidthOnConflict: cats.Show[ExploreResizableWidthOnConflict] =
        cats.Show.fromToString
      implicit val jsonEncoderExploreResizableWidthOnConflict
        : io.circe.Encoder[ExploreResizableWidthOnConflict]                                        = io.circe.generic.semiauto
        .deriveEncoder[ExploreResizableWidthOnConflict]
        .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class ExploreResizableWidthOrderBy(
      val section: clue.data.Input[OrderBy] = clue.data.Ignore,
      val user_id: clue.data.Input[OrderBy] = clue.data.Ignore,
      val width:   clue.data.Input[OrderBy] = clue.data.Ignore
    )
    object ExploreResizableWidthOrderBy {
      implicit val section: monocle.Lens[ExploreResizableWidthOrderBy, clue.data.Input[OrderBy]] =
        monocle.macros.GenLens[ExploreResizableWidthOrderBy](_.section)
      implicit val user_id: monocle.Lens[ExploreResizableWidthOrderBy, clue.data.Input[OrderBy]] =
        monocle.macros.GenLens[ExploreResizableWidthOrderBy](_.user_id)
      implicit val width: monocle.Lens[ExploreResizableWidthOrderBy, clue.data.Input[OrderBy]]   =
        monocle.macros.GenLens[ExploreResizableWidthOrderBy](_.width)
      implicit val eqExploreResizableWidthOrderBy: cats.Eq[ExploreResizableWidthOrderBy]         =
        cats.Eq.fromUniversalEquals
      implicit val showExploreResizableWidthOrderBy: cats.Show[ExploreResizableWidthOrderBy]     =
        cats.Show.fromToString
      implicit val jsonEncoderExploreResizableWidthOrderBy
        : io.circe.Encoder[ExploreResizableWidthOrderBy]                                         = io.circe.generic.semiauto
        .deriveEncoder[ExploreResizableWidthOrderBy]
        .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class ExploreResizableWidthPkColumnsInput(val section: ResizableArea, val user_id: String)
    object ExploreResizableWidthPkColumnsInput {
      implicit val section: monocle.Lens[ExploreResizableWidthPkColumnsInput, ResizableArea] =
        monocle.macros.GenLens[ExploreResizableWidthPkColumnsInput](_.section)
      implicit val user_id: monocle.Lens[ExploreResizableWidthPkColumnsInput, String]        =
        monocle.macros.GenLens[ExploreResizableWidthPkColumnsInput](_.user_id)
      implicit val eqExploreResizableWidthPkColumnsInput
        : cats.Eq[ExploreResizableWidthPkColumnsInput]                                       = cats.Eq.fromUniversalEquals
      implicit val showExploreResizableWidthPkColumnsInput
        : cats.Show[ExploreResizableWidthPkColumnsInput]                                     = cats.Show.fromToString
      implicit val jsonEncoderExploreResizableWidthPkColumnsInput
        : io.circe.Encoder[ExploreResizableWidthPkColumnsInput]                              = io.circe.generic.semiauto
        .deriveEncoder[ExploreResizableWidthPkColumnsInput]
        .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class ExploreResizableWidthSetInput(
      val section: clue.data.Input[ResizableArea] = clue.data.Ignore,
      val user_id: clue.data.Input[String] = clue.data.Ignore,
      val width:   clue.data.Input[Int] = clue.data.Ignore
    )
    object ExploreResizableWidthSetInput {
      implicit val section
        : monocle.Lens[ExploreResizableWidthSetInput, clue.data.Input[ResizableArea]]            =
        monocle.macros.GenLens[ExploreResizableWidthSetInput](_.section)
      implicit val user_id: monocle.Lens[ExploreResizableWidthSetInput, clue.data.Input[String]] =
        monocle.macros.GenLens[ExploreResizableWidthSetInput](_.user_id)
      implicit val width: monocle.Lens[ExploreResizableWidthSetInput, clue.data.Input[Int]]      =
        monocle.macros.GenLens[ExploreResizableWidthSetInput](_.width)
      implicit val eqExploreResizableWidthSetInput: cats.Eq[ExploreResizableWidthSetInput]       =
        cats.Eq.fromUniversalEquals
      implicit val showExploreResizableWidthSetInput: cats.Show[ExploreResizableWidthSetInput]   =
        cats.Show.fromToString
      implicit val jsonEncoderExploreResizableWidthSetInput
        : io.circe.Encoder[ExploreResizableWidthSetInput]                                        = io.circe.generic.semiauto
        .deriveEncoder[ExploreResizableWidthSetInput]
        .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class ExploreResizableWidthStddevOrderBy(
      val width: clue.data.Input[OrderBy] = clue.data.Ignore
    )
    object ExploreResizableWidthStddevOrderBy {
      implicit val width
        : monocle.Lens[ExploreResizableWidthStddevOrderBy, clue.data.Input[OrderBy]] =
        monocle.macros.GenLens[ExploreResizableWidthStddevOrderBy](_.width)
      implicit val eqExploreResizableWidthStddevOrderBy
        : cats.Eq[ExploreResizableWidthStddevOrderBy]                                = cats.Eq.fromUniversalEquals
      implicit val showExploreResizableWidthStddevOrderBy
        : cats.Show[ExploreResizableWidthStddevOrderBy]                              = cats.Show.fromToString
      implicit val jsonEncoderExploreResizableWidthStddevOrderBy
        : io.circe.Encoder[ExploreResizableWidthStddevOrderBy]                       = io.circe.generic.semiauto
        .deriveEncoder[ExploreResizableWidthStddevOrderBy]
        .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class ExploreResizableWidthStddevPopOrderBy(
      val width: clue.data.Input[OrderBy] = clue.data.Ignore
    )
    object ExploreResizableWidthStddevPopOrderBy {
      implicit val width
        : monocle.Lens[ExploreResizableWidthStddevPopOrderBy, clue.data.Input[OrderBy]] =
        monocle.macros.GenLens[ExploreResizableWidthStddevPopOrderBy](_.width)
      implicit val eqExploreResizableWidthStddevPopOrderBy
        : cats.Eq[ExploreResizableWidthStddevPopOrderBy]                                = cats.Eq.fromUniversalEquals
      implicit val showExploreResizableWidthStddevPopOrderBy
        : cats.Show[ExploreResizableWidthStddevPopOrderBy]                              = cats.Show.fromToString
      implicit val jsonEncoderExploreResizableWidthStddevPopOrderBy
        : io.circe.Encoder[ExploreResizableWidthStddevPopOrderBy]                       = io.circe.generic.semiauto
        .deriveEncoder[ExploreResizableWidthStddevPopOrderBy]
        .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class ExploreResizableWidthStddevSampOrderBy(
      val width: clue.data.Input[OrderBy] = clue.data.Ignore
    )
    object ExploreResizableWidthStddevSampOrderBy {
      implicit val width
        : monocle.Lens[ExploreResizableWidthStddevSampOrderBy, clue.data.Input[OrderBy]] =
        monocle.macros.GenLens[ExploreResizableWidthStddevSampOrderBy](_.width)
      implicit val eqExploreResizableWidthStddevSampOrderBy
        : cats.Eq[ExploreResizableWidthStddevSampOrderBy]                                = cats.Eq.fromUniversalEquals
      implicit val showExploreResizableWidthStddevSampOrderBy
        : cats.Show[ExploreResizableWidthStddevSampOrderBy]                              = cats.Show.fromToString
      implicit val jsonEncoderExploreResizableWidthStddevSampOrderBy
        : io.circe.Encoder[ExploreResizableWidthStddevSampOrderBy]                       = io.circe.generic.semiauto
        .deriveEncoder[ExploreResizableWidthStddevSampOrderBy]
        .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class ExploreResizableWidthSumOrderBy(
      val width: clue.data.Input[OrderBy] = clue.data.Ignore
    )
    object ExploreResizableWidthSumOrderBy {
      implicit val width: monocle.Lens[ExploreResizableWidthSumOrderBy, clue.data.Input[OrderBy]]  =
        monocle.macros.GenLens[ExploreResizableWidthSumOrderBy](_.width)
      implicit val eqExploreResizableWidthSumOrderBy: cats.Eq[ExploreResizableWidthSumOrderBy]     =
        cats.Eq.fromUniversalEquals
      implicit val showExploreResizableWidthSumOrderBy: cats.Show[ExploreResizableWidthSumOrderBy] =
        cats.Show.fromToString
      implicit val jsonEncoderExploreResizableWidthSumOrderBy
        : io.circe.Encoder[ExploreResizableWidthSumOrderBy]                                        = io.circe.generic.semiauto
        .deriveEncoder[ExploreResizableWidthSumOrderBy]
        .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class ExploreResizableWidthVarPopOrderBy(
      val width: clue.data.Input[OrderBy] = clue.data.Ignore
    )
    object ExploreResizableWidthVarPopOrderBy {
      implicit val width
        : monocle.Lens[ExploreResizableWidthVarPopOrderBy, clue.data.Input[OrderBy]] =
        monocle.macros.GenLens[ExploreResizableWidthVarPopOrderBy](_.width)
      implicit val eqExploreResizableWidthVarPopOrderBy
        : cats.Eq[ExploreResizableWidthVarPopOrderBy]                                = cats.Eq.fromUniversalEquals
      implicit val showExploreResizableWidthVarPopOrderBy
        : cats.Show[ExploreResizableWidthVarPopOrderBy]                              = cats.Show.fromToString
      implicit val jsonEncoderExploreResizableWidthVarPopOrderBy
        : io.circe.Encoder[ExploreResizableWidthVarPopOrderBy]                       = io.circe.generic.semiauto
        .deriveEncoder[ExploreResizableWidthVarPopOrderBy]
        .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class ExploreResizableWidthVarSampOrderBy(
      val width: clue.data.Input[OrderBy] = clue.data.Ignore
    )
    object ExploreResizableWidthVarSampOrderBy {
      implicit val width
        : monocle.Lens[ExploreResizableWidthVarSampOrderBy, clue.data.Input[OrderBy]] =
        monocle.macros.GenLens[ExploreResizableWidthVarSampOrderBy](_.width)
      implicit val eqExploreResizableWidthVarSampOrderBy
        : cats.Eq[ExploreResizableWidthVarSampOrderBy]                                = cats.Eq.fromUniversalEquals
      implicit val showExploreResizableWidthVarSampOrderBy
        : cats.Show[ExploreResizableWidthVarSampOrderBy]                              = cats.Show.fromToString
      implicit val jsonEncoderExploreResizableWidthVarSampOrderBy
        : io.circe.Encoder[ExploreResizableWidthVarSampOrderBy]                       = io.circe.generic.semiauto
        .deriveEncoder[ExploreResizableWidthVarSampOrderBy]
        .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class ExploreResizableWidthVarianceOrderBy(
      val width: clue.data.Input[OrderBy] = clue.data.Ignore
    )
    object ExploreResizableWidthVarianceOrderBy {
      implicit val width
        : monocle.Lens[ExploreResizableWidthVarianceOrderBy, clue.data.Input[OrderBy]] =
        monocle.macros.GenLens[ExploreResizableWidthVarianceOrderBy](_.width)
      implicit val eqExploreResizableWidthVarianceOrderBy
        : cats.Eq[ExploreResizableWidthVarianceOrderBy]                                = cats.Eq.fromUniversalEquals
      implicit val showExploreResizableWidthVarianceOrderBy
        : cats.Show[ExploreResizableWidthVarianceOrderBy]                              = cats.Show.fromToString
      implicit val jsonEncoderExploreResizableWidthVarianceOrderBy
        : io.circe.Encoder[ExploreResizableWidthVarianceOrderBy]                       = io.circe.generic.semiauto
        .deriveEncoder[ExploreResizableWidthVarianceOrderBy]
        .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class GridLayoutAreaComparisonExp(
      val _eq:      clue.data.Input[GridLayoutArea] = clue.data.Ignore,
      val _gt:      clue.data.Input[GridLayoutArea] = clue.data.Ignore,
      val _gte:     clue.data.Input[GridLayoutArea] = clue.data.Ignore,
      val _in:      clue.data.Input[List[GridLayoutArea]] = clue.data.Ignore,
      val _is_null: clue.data.Input[Boolean] = clue.data.Ignore,
      val _lt:      clue.data.Input[GridLayoutArea] = clue.data.Ignore,
      val _lte:     clue.data.Input[GridLayoutArea] = clue.data.Ignore,
      val _neq:     clue.data.Input[GridLayoutArea] = clue.data.Ignore,
      val _nin:     clue.data.Input[List[GridLayoutArea]] = clue.data.Ignore
    )
    object GridLayoutAreaComparisonExp {
      implicit val _eq: monocle.Lens[GridLayoutAreaComparisonExp, clue.data.Input[GridLayoutArea]] =
        monocle.macros.GenLens[GridLayoutAreaComparisonExp](_._eq)
      implicit val _gt: monocle.Lens[GridLayoutAreaComparisonExp, clue.data.Input[GridLayoutArea]] =
        monocle.macros.GenLens[GridLayoutAreaComparisonExp](_._gt)
      implicit val _gte
        : monocle.Lens[GridLayoutAreaComparisonExp, clue.data.Input[GridLayoutArea]]               =
        monocle.macros.GenLens[GridLayoutAreaComparisonExp](_._gte)
      implicit val _in
        : monocle.Lens[GridLayoutAreaComparisonExp, clue.data.Input[List[GridLayoutArea]]]         =
        monocle.macros.GenLens[GridLayoutAreaComparisonExp](_._in)
      implicit val _is_null: monocle.Lens[GridLayoutAreaComparisonExp, clue.data.Input[Boolean]]   =
        monocle.macros.GenLens[GridLayoutAreaComparisonExp](_._is_null)
      implicit val _lt: monocle.Lens[GridLayoutAreaComparisonExp, clue.data.Input[GridLayoutArea]] =
        monocle.macros.GenLens[GridLayoutAreaComparisonExp](_._lt)
      implicit val _lte
        : monocle.Lens[GridLayoutAreaComparisonExp, clue.data.Input[GridLayoutArea]]               =
        monocle.macros.GenLens[GridLayoutAreaComparisonExp](_._lte)
      implicit val _neq
        : monocle.Lens[GridLayoutAreaComparisonExp, clue.data.Input[GridLayoutArea]]               =
        monocle.macros.GenLens[GridLayoutAreaComparisonExp](_._neq)
      implicit val _nin
        : monocle.Lens[GridLayoutAreaComparisonExp, clue.data.Input[List[GridLayoutArea]]]         =
        monocle.macros.GenLens[GridLayoutAreaComparisonExp](_._nin)
      implicit val eqGridLayoutAreaComparisonExp: cats.Eq[GridLayoutAreaComparisonExp]             =
        cats.Eq.fromUniversalEquals
      implicit val showGridLayoutAreaComparisonExp: cats.Show[GridLayoutAreaComparisonExp]         =
        cats.Show.fromToString
      implicit val jsonEncoderGridLayoutAreaComparisonExp
        : io.circe.Encoder[GridLayoutAreaComparisonExp]                                            = io.circe.generic.semiauto
        .deriveEncoder[GridLayoutAreaComparisonExp]
        .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class GridLayoutPositionsAggregateOrderBy(
      val avg:         clue.data.Input[GridLayoutPositionsAvgOrderBy] = clue.data.Ignore,
      val count:       clue.data.Input[OrderBy] = clue.data.Ignore,
      val max:         clue.data.Input[GridLayoutPositionsMaxOrderBy] = clue.data.Ignore,
      val min:         clue.data.Input[GridLayoutPositionsMinOrderBy] = clue.data.Ignore,
      val stddev:      clue.data.Input[GridLayoutPositionsStddevOrderBy] = clue.data.Ignore,
      val stddev_pop:  clue.data.Input[GridLayoutPositionsStddevPopOrderBy] = clue.data.Ignore,
      val stddev_samp: clue.data.Input[GridLayoutPositionsStddevSampOrderBy] = clue.data.Ignore,
      val sum:         clue.data.Input[GridLayoutPositionsSumOrderBy] = clue.data.Ignore,
      val var_pop:     clue.data.Input[GridLayoutPositionsVarPopOrderBy] = clue.data.Ignore,
      val var_samp:    clue.data.Input[GridLayoutPositionsVarSampOrderBy] = clue.data.Ignore,
      val variance:    clue.data.Input[GridLayoutPositionsVarianceOrderBy] = clue.data.Ignore
    )
    object GridLayoutPositionsAggregateOrderBy {
      implicit val avg: monocle.Lens[GridLayoutPositionsAggregateOrderBy, clue.data.Input[
        GridLayoutPositionsAvgOrderBy
      ]]                                                                              = monocle.macros.GenLens[GridLayoutPositionsAggregateOrderBy](_.avg)
      implicit val count
        : monocle.Lens[GridLayoutPositionsAggregateOrderBy, clue.data.Input[OrderBy]] =
        monocle.macros.GenLens[GridLayoutPositionsAggregateOrderBy](_.count)
      implicit val max: monocle.Lens[GridLayoutPositionsAggregateOrderBy, clue.data.Input[
        GridLayoutPositionsMaxOrderBy
      ]]                                                                              = monocle.macros.GenLens[GridLayoutPositionsAggregateOrderBy](_.max)
      implicit val min: monocle.Lens[GridLayoutPositionsAggregateOrderBy, clue.data.Input[
        GridLayoutPositionsMinOrderBy
      ]]                                                                              = monocle.macros.GenLens[GridLayoutPositionsAggregateOrderBy](_.min)
      implicit val stddev: monocle.Lens[GridLayoutPositionsAggregateOrderBy, clue.data.Input[
        GridLayoutPositionsStddevOrderBy
      ]]                                                                              = monocle.macros.GenLens[GridLayoutPositionsAggregateOrderBy](_.stddev)
      implicit val stddev_pop: monocle.Lens[GridLayoutPositionsAggregateOrderBy, clue.data.Input[
        GridLayoutPositionsStddevPopOrderBy
      ]]                                                                              = monocle.macros.GenLens[GridLayoutPositionsAggregateOrderBy](_.stddev_pop)
      implicit val stddev_samp: monocle.Lens[GridLayoutPositionsAggregateOrderBy, clue.data.Input[
        GridLayoutPositionsStddevSampOrderBy
      ]]                                                                              = monocle.macros.GenLens[GridLayoutPositionsAggregateOrderBy](_.stddev_samp)
      implicit val sum: monocle.Lens[GridLayoutPositionsAggregateOrderBy, clue.data.Input[
        GridLayoutPositionsSumOrderBy
      ]]                                                                              = monocle.macros.GenLens[GridLayoutPositionsAggregateOrderBy](_.sum)
      implicit val var_pop: monocle.Lens[GridLayoutPositionsAggregateOrderBy, clue.data.Input[
        GridLayoutPositionsVarPopOrderBy
      ]]                                                                              = monocle.macros.GenLens[GridLayoutPositionsAggregateOrderBy](_.var_pop)
      implicit val var_samp: monocle.Lens[GridLayoutPositionsAggregateOrderBy, clue.data.Input[
        GridLayoutPositionsVarSampOrderBy
      ]]                                                                              = monocle.macros.GenLens[GridLayoutPositionsAggregateOrderBy](_.var_samp)
      implicit val variance: monocle.Lens[GridLayoutPositionsAggregateOrderBy, clue.data.Input[
        GridLayoutPositionsVarianceOrderBy
      ]]                                                                              = monocle.macros.GenLens[GridLayoutPositionsAggregateOrderBy](_.variance)
      implicit val eqGridLayoutPositionsAggregateOrderBy
        : cats.Eq[GridLayoutPositionsAggregateOrderBy]                                = cats.Eq.fromUniversalEquals
      implicit val showGridLayoutPositionsAggregateOrderBy
        : cats.Show[GridLayoutPositionsAggregateOrderBy]                              = cats.Show.fromToString
      implicit val jsonEncoderGridLayoutPositionsAggregateOrderBy
        : io.circe.Encoder[GridLayoutPositionsAggregateOrderBy]                       = io.circe.generic.semiauto
        .deriveEncoder[GridLayoutPositionsAggregateOrderBy]
        .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class GridLayoutPositionsArrRelInsertInput(
      val data:        List[GridLayoutPositionsInsertInput],
      val on_conflict: clue.data.Input[GridLayoutPositionsOnConflict] = clue.data.Ignore
    )
    object GridLayoutPositionsArrRelInsertInput {
      implicit val data
        : monocle.Lens[GridLayoutPositionsArrRelInsertInput, List[GridLayoutPositionsInsertInput]] =
        monocle.macros.GenLens[GridLayoutPositionsArrRelInsertInput](_.data)
      implicit val on_conflict: monocle.Lens[GridLayoutPositionsArrRelInsertInput, clue.data.Input[
        GridLayoutPositionsOnConflict
      ]]                                                                                           = monocle.macros.GenLens[GridLayoutPositionsArrRelInsertInput](_.on_conflict)
      implicit val eqGridLayoutPositionsArrRelInsertInput
        : cats.Eq[GridLayoutPositionsArrRelInsertInput]                                            = cats.Eq.fromUniversalEquals
      implicit val showGridLayoutPositionsArrRelInsertInput
        : cats.Show[GridLayoutPositionsArrRelInsertInput]                                          = cats.Show.fromToString
      implicit val jsonEncoderGridLayoutPositionsArrRelInsertInput
        : io.circe.Encoder[GridLayoutPositionsArrRelInsertInput]                                   = io.circe.generic.semiauto
        .deriveEncoder[GridLayoutPositionsArrRelInsertInput]
        .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class GridLayoutPositionsAvgOrderBy(
      val height: clue.data.Input[OrderBy] = clue.data.Ignore,
      val width:  clue.data.Input[OrderBy] = clue.data.Ignore,
      val x:      clue.data.Input[OrderBy] = clue.data.Ignore,
      val y:      clue.data.Input[OrderBy] = clue.data.Ignore
    )
    object GridLayoutPositionsAvgOrderBy {
      implicit val height: monocle.Lens[GridLayoutPositionsAvgOrderBy, clue.data.Input[OrderBy]] =
        monocle.macros.GenLens[GridLayoutPositionsAvgOrderBy](_.height)
      implicit val width: monocle.Lens[GridLayoutPositionsAvgOrderBy, clue.data.Input[OrderBy]]  =
        monocle.macros.GenLens[GridLayoutPositionsAvgOrderBy](_.width)
      implicit val x: monocle.Lens[GridLayoutPositionsAvgOrderBy, clue.data.Input[OrderBy]]      =
        monocle.macros.GenLens[GridLayoutPositionsAvgOrderBy](_.x)
      implicit val y: monocle.Lens[GridLayoutPositionsAvgOrderBy, clue.data.Input[OrderBy]]      =
        monocle.macros.GenLens[GridLayoutPositionsAvgOrderBy](_.y)
      implicit val eqGridLayoutPositionsAvgOrderBy: cats.Eq[GridLayoutPositionsAvgOrderBy]       =
        cats.Eq.fromUniversalEquals
      implicit val showGridLayoutPositionsAvgOrderBy: cats.Show[GridLayoutPositionsAvgOrderBy]   =
        cats.Show.fromToString
      implicit val jsonEncoderGridLayoutPositionsAvgOrderBy
        : io.circe.Encoder[GridLayoutPositionsAvgOrderBy]                                        = io.circe.generic.semiauto
        .deriveEncoder[GridLayoutPositionsAvgOrderBy]
        .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class GridLayoutPositionsBoolExp(
      val _and:            clue.data.Input[List[clue.data.Input[GridLayoutPositionsBoolExp]]] =
        clue.data.Ignore,
      val _not:            clue.data.Input[GridLayoutPositionsBoolExp] = clue.data.Ignore,
      val _or:             clue.data.Input[List[clue.data.Input[GridLayoutPositionsBoolExp]]] =
        clue.data.Ignore,
      val breakpoint_name: clue.data.Input[BreakpointNameComparisonExp] = clue.data.Ignore,
      val height:          clue.data.Input[IntComparisonExp] = clue.data.Ignore,
      val section:         clue.data.Input[GridLayoutAreaComparisonExp] = clue.data.Ignore,
      val tile:            clue.data.Input[StringComparisonExp] = clue.data.Ignore,
      val user_id:         clue.data.Input[StringComparisonExp] = clue.data.Ignore,
      val width:           clue.data.Input[IntComparisonExp] = clue.data.Ignore,
      val x:               clue.data.Input[IntComparisonExp] = clue.data.Ignore,
      val y:               clue.data.Input[IntComparisonExp] = clue.data.Ignore
    )
    object GridLayoutPositionsBoolExp {
      implicit val _and: monocle.Lens[GridLayoutPositionsBoolExp, clue.data.Input[List[
        clue.data.Input[GridLayoutPositionsBoolExp]
      ]]]                                                                                         = monocle.macros.GenLens[GridLayoutPositionsBoolExp](_._and)
      implicit val _not
        : monocle.Lens[GridLayoutPositionsBoolExp, clue.data.Input[GridLayoutPositionsBoolExp]]   =
        monocle.macros.GenLens[GridLayoutPositionsBoolExp](_._not)
      implicit val _or: monocle.Lens[GridLayoutPositionsBoolExp, clue.data.Input[List[
        clue.data.Input[GridLayoutPositionsBoolExp]
      ]]]                                                                                         = monocle.macros.GenLens[GridLayoutPositionsBoolExp](_._or)
      implicit val breakpoint_name
        : monocle.Lens[GridLayoutPositionsBoolExp, clue.data.Input[BreakpointNameComparisonExp]]  =
        monocle.macros.GenLens[GridLayoutPositionsBoolExp](_.breakpoint_name)
      implicit val height
        : monocle.Lens[GridLayoutPositionsBoolExp, clue.data.Input[IntComparisonExp]]             =
        monocle.macros.GenLens[GridLayoutPositionsBoolExp](_.height)
      implicit val section
        : monocle.Lens[GridLayoutPositionsBoolExp, clue.data.Input[GridLayoutAreaComparisonExp]]  =
        monocle.macros.GenLens[GridLayoutPositionsBoolExp](_.section)
      implicit val tile
        : monocle.Lens[GridLayoutPositionsBoolExp, clue.data.Input[StringComparisonExp]]          =
        monocle.macros.GenLens[GridLayoutPositionsBoolExp](_.tile)
      implicit val user_id
        : monocle.Lens[GridLayoutPositionsBoolExp, clue.data.Input[StringComparisonExp]]          =
        monocle.macros.GenLens[GridLayoutPositionsBoolExp](_.user_id)
      implicit val width
        : monocle.Lens[GridLayoutPositionsBoolExp, clue.data.Input[IntComparisonExp]]             =
        monocle.macros.GenLens[GridLayoutPositionsBoolExp](_.width)
      implicit val x: monocle.Lens[GridLayoutPositionsBoolExp, clue.data.Input[IntComparisonExp]] =
        monocle.macros.GenLens[GridLayoutPositionsBoolExp](_.x)
      implicit val y: monocle.Lens[GridLayoutPositionsBoolExp, clue.data.Input[IntComparisonExp]] =
        monocle.macros.GenLens[GridLayoutPositionsBoolExp](_.y)
      implicit val eqGridLayoutPositionsBoolExp: cats.Eq[GridLayoutPositionsBoolExp]              =
        cats.Eq.fromUniversalEquals
      implicit val showGridLayoutPositionsBoolExp: cats.Show[GridLayoutPositionsBoolExp]          =
        cats.Show.fromToString
      implicit val jsonEncoderGridLayoutPositionsBoolExp
        : io.circe.Encoder[GridLayoutPositionsBoolExp]                                            = io.circe.generic.semiauto
        .deriveEncoder[GridLayoutPositionsBoolExp]
        .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class GridLayoutPositionsIncInput(
      val height: clue.data.Input[Int] = clue.data.Ignore,
      val width:  clue.data.Input[Int] = clue.data.Ignore,
      val x:      clue.data.Input[Int] = clue.data.Ignore,
      val y:      clue.data.Input[Int] = clue.data.Ignore
    )
    object GridLayoutPositionsIncInput {
      implicit val height: monocle.Lens[GridLayoutPositionsIncInput, clue.data.Input[Int]] =
        monocle.macros.GenLens[GridLayoutPositionsIncInput](_.height)
      implicit val width: monocle.Lens[GridLayoutPositionsIncInput, clue.data.Input[Int]]  =
        monocle.macros.GenLens[GridLayoutPositionsIncInput](_.width)
      implicit val x: monocle.Lens[GridLayoutPositionsIncInput, clue.data.Input[Int]]      =
        monocle.macros.GenLens[GridLayoutPositionsIncInput](_.x)
      implicit val y: monocle.Lens[GridLayoutPositionsIncInput, clue.data.Input[Int]]      =
        monocle.macros.GenLens[GridLayoutPositionsIncInput](_.y)
      implicit val eqGridLayoutPositionsIncInput: cats.Eq[GridLayoutPositionsIncInput]     =
        cats.Eq.fromUniversalEquals
      implicit val showGridLayoutPositionsIncInput: cats.Show[GridLayoutPositionsIncInput] =
        cats.Show.fromToString
      implicit val jsonEncoderGridLayoutPositionsIncInput
        : io.circe.Encoder[GridLayoutPositionsIncInput]                                    = io.circe.generic.semiauto
        .deriveEncoder[GridLayoutPositionsIncInput]
        .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class GridLayoutPositionsInsertInput(
      val breakpoint_name: clue.data.Input[BreakpointName] = clue.data.Ignore,
      val height:          clue.data.Input[Int] = clue.data.Ignore,
      val section:         clue.data.Input[GridLayoutArea] = clue.data.Ignore,
      val tile:            clue.data.Input[String] = clue.data.Ignore,
      val user_id:         clue.data.Input[String] = clue.data.Ignore,
      val width:           clue.data.Input[Int] = clue.data.Ignore,
      val x:               clue.data.Input[Int] = clue.data.Ignore,
      val y:               clue.data.Input[Int] = clue.data.Ignore
    )
    object GridLayoutPositionsInsertInput {
      implicit val breakpoint_name
        : monocle.Lens[GridLayoutPositionsInsertInput, clue.data.Input[BreakpointName]]           =
        monocle.macros.GenLens[GridLayoutPositionsInsertInput](_.breakpoint_name)
      implicit val height: monocle.Lens[GridLayoutPositionsInsertInput, clue.data.Input[Int]]     =
        monocle.macros.GenLens[GridLayoutPositionsInsertInput](_.height)
      implicit val section
        : monocle.Lens[GridLayoutPositionsInsertInput, clue.data.Input[GridLayoutArea]]           =
        monocle.macros.GenLens[GridLayoutPositionsInsertInput](_.section)
      implicit val tile: monocle.Lens[GridLayoutPositionsInsertInput, clue.data.Input[String]]    =
        monocle.macros.GenLens[GridLayoutPositionsInsertInput](_.tile)
      implicit val user_id: monocle.Lens[GridLayoutPositionsInsertInput, clue.data.Input[String]] =
        monocle.macros.GenLens[GridLayoutPositionsInsertInput](_.user_id)
      implicit val width: monocle.Lens[GridLayoutPositionsInsertInput, clue.data.Input[Int]]      =
        monocle.macros.GenLens[GridLayoutPositionsInsertInput](_.width)
      implicit val x: monocle.Lens[GridLayoutPositionsInsertInput, clue.data.Input[Int]]          =
        monocle.macros.GenLens[GridLayoutPositionsInsertInput](_.x)
      implicit val y: monocle.Lens[GridLayoutPositionsInsertInput, clue.data.Input[Int]]          =
        monocle.macros.GenLens[GridLayoutPositionsInsertInput](_.y)
      implicit val eqGridLayoutPositionsInsertInput: cats.Eq[GridLayoutPositionsInsertInput]      =
        cats.Eq.fromUniversalEquals
      implicit val showGridLayoutPositionsInsertInput: cats.Show[GridLayoutPositionsInsertInput]  =
        cats.Show.fromToString
      implicit val jsonEncoderGridLayoutPositionsInsertInput
        : io.circe.Encoder[GridLayoutPositionsInsertInput]                                        = io.circe.generic.semiauto
        .deriveEncoder[GridLayoutPositionsInsertInput]
        .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class GridLayoutPositionsMaxOrderBy(
      val height:  clue.data.Input[OrderBy] = clue.data.Ignore,
      val tile:    clue.data.Input[OrderBy] = clue.data.Ignore,
      val user_id: clue.data.Input[OrderBy] = clue.data.Ignore,
      val width:   clue.data.Input[OrderBy] = clue.data.Ignore,
      val x:       clue.data.Input[OrderBy] = clue.data.Ignore,
      val y:       clue.data.Input[OrderBy] = clue.data.Ignore
    )
    object GridLayoutPositionsMaxOrderBy {
      implicit val height: monocle.Lens[GridLayoutPositionsMaxOrderBy, clue.data.Input[OrderBy]]  =
        monocle.macros.GenLens[GridLayoutPositionsMaxOrderBy](_.height)
      implicit val tile: monocle.Lens[GridLayoutPositionsMaxOrderBy, clue.data.Input[OrderBy]]    =
        monocle.macros.GenLens[GridLayoutPositionsMaxOrderBy](_.tile)
      implicit val user_id: monocle.Lens[GridLayoutPositionsMaxOrderBy, clue.data.Input[OrderBy]] =
        monocle.macros.GenLens[GridLayoutPositionsMaxOrderBy](_.user_id)
      implicit val width: monocle.Lens[GridLayoutPositionsMaxOrderBy, clue.data.Input[OrderBy]]   =
        monocle.macros.GenLens[GridLayoutPositionsMaxOrderBy](_.width)
      implicit val x: monocle.Lens[GridLayoutPositionsMaxOrderBy, clue.data.Input[OrderBy]]       =
        monocle.macros.GenLens[GridLayoutPositionsMaxOrderBy](_.x)
      implicit val y: monocle.Lens[GridLayoutPositionsMaxOrderBy, clue.data.Input[OrderBy]]       =
        monocle.macros.GenLens[GridLayoutPositionsMaxOrderBy](_.y)
      implicit val eqGridLayoutPositionsMaxOrderBy: cats.Eq[GridLayoutPositionsMaxOrderBy]        =
        cats.Eq.fromUniversalEquals
      implicit val showGridLayoutPositionsMaxOrderBy: cats.Show[GridLayoutPositionsMaxOrderBy]    =
        cats.Show.fromToString
      implicit val jsonEncoderGridLayoutPositionsMaxOrderBy
        : io.circe.Encoder[GridLayoutPositionsMaxOrderBy]                                         = io.circe.generic.semiauto
        .deriveEncoder[GridLayoutPositionsMaxOrderBy]
        .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class GridLayoutPositionsMinOrderBy(
      val height:  clue.data.Input[OrderBy] = clue.data.Ignore,
      val tile:    clue.data.Input[OrderBy] = clue.data.Ignore,
      val user_id: clue.data.Input[OrderBy] = clue.data.Ignore,
      val width:   clue.data.Input[OrderBy] = clue.data.Ignore,
      val x:       clue.data.Input[OrderBy] = clue.data.Ignore,
      val y:       clue.data.Input[OrderBy] = clue.data.Ignore
    )
    object GridLayoutPositionsMinOrderBy {
      implicit val height: monocle.Lens[GridLayoutPositionsMinOrderBy, clue.data.Input[OrderBy]]  =
        monocle.macros.GenLens[GridLayoutPositionsMinOrderBy](_.height)
      implicit val tile: monocle.Lens[GridLayoutPositionsMinOrderBy, clue.data.Input[OrderBy]]    =
        monocle.macros.GenLens[GridLayoutPositionsMinOrderBy](_.tile)
      implicit val user_id: monocle.Lens[GridLayoutPositionsMinOrderBy, clue.data.Input[OrderBy]] =
        monocle.macros.GenLens[GridLayoutPositionsMinOrderBy](_.user_id)
      implicit val width: monocle.Lens[GridLayoutPositionsMinOrderBy, clue.data.Input[OrderBy]]   =
        monocle.macros.GenLens[GridLayoutPositionsMinOrderBy](_.width)
      implicit val x: monocle.Lens[GridLayoutPositionsMinOrderBy, clue.data.Input[OrderBy]]       =
        monocle.macros.GenLens[GridLayoutPositionsMinOrderBy](_.x)
      implicit val y: monocle.Lens[GridLayoutPositionsMinOrderBy, clue.data.Input[OrderBy]]       =
        monocle.macros.GenLens[GridLayoutPositionsMinOrderBy](_.y)
      implicit val eqGridLayoutPositionsMinOrderBy: cats.Eq[GridLayoutPositionsMinOrderBy]        =
        cats.Eq.fromUniversalEquals
      implicit val showGridLayoutPositionsMinOrderBy: cats.Show[GridLayoutPositionsMinOrderBy]    =
        cats.Show.fromToString
      implicit val jsonEncoderGridLayoutPositionsMinOrderBy
        : io.circe.Encoder[GridLayoutPositionsMinOrderBy]                                         = io.circe.generic.semiauto
        .deriveEncoder[GridLayoutPositionsMinOrderBy]
        .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class GridLayoutPositionsObjRelInsertInput(
      val data:        GridLayoutPositionsInsertInput,
      val on_conflict: clue.data.Input[GridLayoutPositionsOnConflict] = clue.data.Ignore
    )
    object GridLayoutPositionsObjRelInsertInput {
      implicit val data
        : monocle.Lens[GridLayoutPositionsObjRelInsertInput, GridLayoutPositionsInsertInput] =
        monocle.macros.GenLens[GridLayoutPositionsObjRelInsertInput](_.data)
      implicit val on_conflict: monocle.Lens[GridLayoutPositionsObjRelInsertInput, clue.data.Input[
        GridLayoutPositionsOnConflict
      ]]                                                                                     = monocle.macros.GenLens[GridLayoutPositionsObjRelInsertInput](_.on_conflict)
      implicit val eqGridLayoutPositionsObjRelInsertInput
        : cats.Eq[GridLayoutPositionsObjRelInsertInput]                                      = cats.Eq.fromUniversalEquals
      implicit val showGridLayoutPositionsObjRelInsertInput
        : cats.Show[GridLayoutPositionsObjRelInsertInput]                                    = cats.Show.fromToString
      implicit val jsonEncoderGridLayoutPositionsObjRelInsertInput
        : io.circe.Encoder[GridLayoutPositionsObjRelInsertInput]                             = io.circe.generic.semiauto
        .deriveEncoder[GridLayoutPositionsObjRelInsertInput]
        .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class GridLayoutPositionsOnConflict(
      val constraint:     GridLayoutPositionsConstraint,
      val update_columns: List[GridLayoutPositionsUpdateColumn],
      val where:          clue.data.Input[GridLayoutPositionsBoolExp] = clue.data.Ignore
    )
    object GridLayoutPositionsOnConflict {
      implicit val constraint
        : monocle.Lens[GridLayoutPositionsOnConflict, GridLayoutPositionsConstraint]               =
        monocle.macros.GenLens[GridLayoutPositionsOnConflict](_.constraint)
      implicit val update_columns
        : monocle.Lens[GridLayoutPositionsOnConflict, List[GridLayoutPositionsUpdateColumn]]       =
        monocle.macros.GenLens[GridLayoutPositionsOnConflict](_.update_columns)
      implicit val where
        : monocle.Lens[GridLayoutPositionsOnConflict, clue.data.Input[GridLayoutPositionsBoolExp]] =
        monocle.macros.GenLens[GridLayoutPositionsOnConflict](_.where)
      implicit val eqGridLayoutPositionsOnConflict: cats.Eq[GridLayoutPositionsOnConflict]         =
        cats.Eq.fromUniversalEquals
      implicit val showGridLayoutPositionsOnConflict: cats.Show[GridLayoutPositionsOnConflict]     =
        cats.Show.fromToString
      implicit val jsonEncoderGridLayoutPositionsOnConflict
        : io.circe.Encoder[GridLayoutPositionsOnConflict]                                          = io.circe.generic.semiauto
        .deriveEncoder[GridLayoutPositionsOnConflict]
        .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class GridLayoutPositionsOrderBy(
      val breakpoint_name: clue.data.Input[OrderBy] = clue.data.Ignore,
      val height:          clue.data.Input[OrderBy] = clue.data.Ignore,
      val section:         clue.data.Input[OrderBy] = clue.data.Ignore,
      val tile:            clue.data.Input[OrderBy] = clue.data.Ignore,
      val user_id:         clue.data.Input[OrderBy] = clue.data.Ignore,
      val width:           clue.data.Input[OrderBy] = clue.data.Ignore,
      val x:               clue.data.Input[OrderBy] = clue.data.Ignore,
      val y:               clue.data.Input[OrderBy] = clue.data.Ignore
    )
    object GridLayoutPositionsOrderBy {
      implicit val breakpoint_name
        : monocle.Lens[GridLayoutPositionsOrderBy, clue.data.Input[OrderBy]]                   =
        monocle.macros.GenLens[GridLayoutPositionsOrderBy](_.breakpoint_name)
      implicit val height: monocle.Lens[GridLayoutPositionsOrderBy, clue.data.Input[OrderBy]]  =
        monocle.macros.GenLens[GridLayoutPositionsOrderBy](_.height)
      implicit val section: monocle.Lens[GridLayoutPositionsOrderBy, clue.data.Input[OrderBy]] =
        monocle.macros.GenLens[GridLayoutPositionsOrderBy](_.section)
      implicit val tile: monocle.Lens[GridLayoutPositionsOrderBy, clue.data.Input[OrderBy]]    =
        monocle.macros.GenLens[GridLayoutPositionsOrderBy](_.tile)
      implicit val user_id: monocle.Lens[GridLayoutPositionsOrderBy, clue.data.Input[OrderBy]] =
        monocle.macros.GenLens[GridLayoutPositionsOrderBy](_.user_id)
      implicit val width: monocle.Lens[GridLayoutPositionsOrderBy, clue.data.Input[OrderBy]]   =
        monocle.macros.GenLens[GridLayoutPositionsOrderBy](_.width)
      implicit val x: monocle.Lens[GridLayoutPositionsOrderBy, clue.data.Input[OrderBy]]       =
        monocle.macros.GenLens[GridLayoutPositionsOrderBy](_.x)
      implicit val y: monocle.Lens[GridLayoutPositionsOrderBy, clue.data.Input[OrderBy]]       =
        monocle.macros.GenLens[GridLayoutPositionsOrderBy](_.y)
      implicit val eqGridLayoutPositionsOrderBy: cats.Eq[GridLayoutPositionsOrderBy]           =
        cats.Eq.fromUniversalEquals
      implicit val showGridLayoutPositionsOrderBy: cats.Show[GridLayoutPositionsOrderBy]       =
        cats.Show.fromToString
      implicit val jsonEncoderGridLayoutPositionsOrderBy
        : io.circe.Encoder[GridLayoutPositionsOrderBy]                                         = io.circe.generic.semiauto
        .deriveEncoder[GridLayoutPositionsOrderBy]
        .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class GridLayoutPositionsPkColumnsInput(
      val breakpoint_name: BreakpointName,
      val section:         GridLayoutArea,
      val tile:            String,
      val user_id:         String
    )
    object GridLayoutPositionsPkColumnsInput {
      implicit val breakpoint_name
        : monocle.Lens[GridLayoutPositionsPkColumnsInput, BreakpointName]                          =
        monocle.macros.GenLens[GridLayoutPositionsPkColumnsInput](_.breakpoint_name)
      implicit val section: monocle.Lens[GridLayoutPositionsPkColumnsInput, GridLayoutArea]        =
        monocle.macros.GenLens[GridLayoutPositionsPkColumnsInput](_.section)
      implicit val tile: monocle.Lens[GridLayoutPositionsPkColumnsInput, String]                   =
        monocle.macros.GenLens[GridLayoutPositionsPkColumnsInput](_.tile)
      implicit val user_id: monocle.Lens[GridLayoutPositionsPkColumnsInput, String]                =
        monocle.macros.GenLens[GridLayoutPositionsPkColumnsInput](_.user_id)
      implicit val eqGridLayoutPositionsPkColumnsInput: cats.Eq[GridLayoutPositionsPkColumnsInput] =
        cats.Eq.fromUniversalEquals
      implicit val showGridLayoutPositionsPkColumnsInput
        : cats.Show[GridLayoutPositionsPkColumnsInput]                                             = cats.Show.fromToString
      implicit val jsonEncoderGridLayoutPositionsPkColumnsInput
        : io.circe.Encoder[GridLayoutPositionsPkColumnsInput]                                      = io.circe.generic.semiauto
        .deriveEncoder[GridLayoutPositionsPkColumnsInput]
        .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class GridLayoutPositionsSetInput(
      val breakpoint_name: clue.data.Input[BreakpointName] = clue.data.Ignore,
      val height:          clue.data.Input[Int] = clue.data.Ignore,
      val section:         clue.data.Input[GridLayoutArea] = clue.data.Ignore,
      val tile:            clue.data.Input[String] = clue.data.Ignore,
      val user_id:         clue.data.Input[String] = clue.data.Ignore,
      val width:           clue.data.Input[Int] = clue.data.Ignore,
      val x:               clue.data.Input[Int] = clue.data.Ignore,
      val y:               clue.data.Input[Int] = clue.data.Ignore
    )
    object GridLayoutPositionsSetInput {
      implicit val breakpoint_name
        : monocle.Lens[GridLayoutPositionsSetInput, clue.data.Input[BreakpointName]]           =
        monocle.macros.GenLens[GridLayoutPositionsSetInput](_.breakpoint_name)
      implicit val height: monocle.Lens[GridLayoutPositionsSetInput, clue.data.Input[Int]]     =
        monocle.macros.GenLens[GridLayoutPositionsSetInput](_.height)
      implicit val section
        : monocle.Lens[GridLayoutPositionsSetInput, clue.data.Input[GridLayoutArea]]           =
        monocle.macros.GenLens[GridLayoutPositionsSetInput](_.section)
      implicit val tile: monocle.Lens[GridLayoutPositionsSetInput, clue.data.Input[String]]    =
        monocle.macros.GenLens[GridLayoutPositionsSetInput](_.tile)
      implicit val user_id: monocle.Lens[GridLayoutPositionsSetInput, clue.data.Input[String]] =
        monocle.macros.GenLens[GridLayoutPositionsSetInput](_.user_id)
      implicit val width: monocle.Lens[GridLayoutPositionsSetInput, clue.data.Input[Int]]      =
        monocle.macros.GenLens[GridLayoutPositionsSetInput](_.width)
      implicit val x: monocle.Lens[GridLayoutPositionsSetInput, clue.data.Input[Int]]          =
        monocle.macros.GenLens[GridLayoutPositionsSetInput](_.x)
      implicit val y: monocle.Lens[GridLayoutPositionsSetInput, clue.data.Input[Int]]          =
        monocle.macros.GenLens[GridLayoutPositionsSetInput](_.y)
      implicit val eqGridLayoutPositionsSetInput: cats.Eq[GridLayoutPositionsSetInput]         =
        cats.Eq.fromUniversalEquals
      implicit val showGridLayoutPositionsSetInput: cats.Show[GridLayoutPositionsSetInput]     =
        cats.Show.fromToString
      implicit val jsonEncoderGridLayoutPositionsSetInput
        : io.circe.Encoder[GridLayoutPositionsSetInput]                                        = io.circe.generic.semiauto
        .deriveEncoder[GridLayoutPositionsSetInput]
        .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class GridLayoutPositionsStddevOrderBy(
      val height: clue.data.Input[OrderBy] = clue.data.Ignore,
      val width:  clue.data.Input[OrderBy] = clue.data.Ignore,
      val x:      clue.data.Input[OrderBy] = clue.data.Ignore,
      val y:      clue.data.Input[OrderBy] = clue.data.Ignore
    )
    object GridLayoutPositionsStddevOrderBy {
      implicit val height
        : monocle.Lens[GridLayoutPositionsStddevOrderBy, clue.data.Input[OrderBy]]                 =
        monocle.macros.GenLens[GridLayoutPositionsStddevOrderBy](_.height)
      implicit val width: monocle.Lens[GridLayoutPositionsStddevOrderBy, clue.data.Input[OrderBy]] =
        monocle.macros.GenLens[GridLayoutPositionsStddevOrderBy](_.width)
      implicit val x: monocle.Lens[GridLayoutPositionsStddevOrderBy, clue.data.Input[OrderBy]]     =
        monocle.macros.GenLens[GridLayoutPositionsStddevOrderBy](_.x)
      implicit val y: monocle.Lens[GridLayoutPositionsStddevOrderBy, clue.data.Input[OrderBy]]     =
        monocle.macros.GenLens[GridLayoutPositionsStddevOrderBy](_.y)
      implicit val eqGridLayoutPositionsStddevOrderBy: cats.Eq[GridLayoutPositionsStddevOrderBy]   =
        cats.Eq.fromUniversalEquals
      implicit val showGridLayoutPositionsStddevOrderBy
        : cats.Show[GridLayoutPositionsStddevOrderBy]                                              = cats.Show.fromToString
      implicit val jsonEncoderGridLayoutPositionsStddevOrderBy
        : io.circe.Encoder[GridLayoutPositionsStddevOrderBy]                                       = io.circe.generic.semiauto
        .deriveEncoder[GridLayoutPositionsStddevOrderBy]
        .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class GridLayoutPositionsStddevPopOrderBy(
      val height: clue.data.Input[OrderBy] = clue.data.Ignore,
      val width:  clue.data.Input[OrderBy] = clue.data.Ignore,
      val x:      clue.data.Input[OrderBy] = clue.data.Ignore,
      val y:      clue.data.Input[OrderBy] = clue.data.Ignore
    )
    object GridLayoutPositionsStddevPopOrderBy {
      implicit val height
        : monocle.Lens[GridLayoutPositionsStddevPopOrderBy, clue.data.Input[OrderBy]]             =
        monocle.macros.GenLens[GridLayoutPositionsStddevPopOrderBy](_.height)
      implicit val width
        : monocle.Lens[GridLayoutPositionsStddevPopOrderBy, clue.data.Input[OrderBy]]             =
        monocle.macros.GenLens[GridLayoutPositionsStddevPopOrderBy](_.width)
      implicit val x: monocle.Lens[GridLayoutPositionsStddevPopOrderBy, clue.data.Input[OrderBy]] =
        monocle.macros.GenLens[GridLayoutPositionsStddevPopOrderBy](_.x)
      implicit val y: monocle.Lens[GridLayoutPositionsStddevPopOrderBy, clue.data.Input[OrderBy]] =
        monocle.macros.GenLens[GridLayoutPositionsStddevPopOrderBy](_.y)
      implicit val eqGridLayoutPositionsStddevPopOrderBy
        : cats.Eq[GridLayoutPositionsStddevPopOrderBy]                                            = cats.Eq.fromUniversalEquals
      implicit val showGridLayoutPositionsStddevPopOrderBy
        : cats.Show[GridLayoutPositionsStddevPopOrderBy]                                          = cats.Show.fromToString
      implicit val jsonEncoderGridLayoutPositionsStddevPopOrderBy
        : io.circe.Encoder[GridLayoutPositionsStddevPopOrderBy]                                   = io.circe.generic.semiauto
        .deriveEncoder[GridLayoutPositionsStddevPopOrderBy]
        .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class GridLayoutPositionsStddevSampOrderBy(
      val height: clue.data.Input[OrderBy] = clue.data.Ignore,
      val width:  clue.data.Input[OrderBy] = clue.data.Ignore,
      val x:      clue.data.Input[OrderBy] = clue.data.Ignore,
      val y:      clue.data.Input[OrderBy] = clue.data.Ignore
    )
    object GridLayoutPositionsStddevSampOrderBy {
      implicit val height
        : monocle.Lens[GridLayoutPositionsStddevSampOrderBy, clue.data.Input[OrderBy]]             =
        monocle.macros.GenLens[GridLayoutPositionsStddevSampOrderBy](_.height)
      implicit val width
        : monocle.Lens[GridLayoutPositionsStddevSampOrderBy, clue.data.Input[OrderBy]]             =
        monocle.macros.GenLens[GridLayoutPositionsStddevSampOrderBy](_.width)
      implicit val x: monocle.Lens[GridLayoutPositionsStddevSampOrderBy, clue.data.Input[OrderBy]] =
        monocle.macros.GenLens[GridLayoutPositionsStddevSampOrderBy](_.x)
      implicit val y: monocle.Lens[GridLayoutPositionsStddevSampOrderBy, clue.data.Input[OrderBy]] =
        monocle.macros.GenLens[GridLayoutPositionsStddevSampOrderBy](_.y)
      implicit val eqGridLayoutPositionsStddevSampOrderBy
        : cats.Eq[GridLayoutPositionsStddevSampOrderBy]                                            = cats.Eq.fromUniversalEquals
      implicit val showGridLayoutPositionsStddevSampOrderBy
        : cats.Show[GridLayoutPositionsStddevSampOrderBy]                                          = cats.Show.fromToString
      implicit val jsonEncoderGridLayoutPositionsStddevSampOrderBy
        : io.circe.Encoder[GridLayoutPositionsStddevSampOrderBy]                                   = io.circe.generic.semiauto
        .deriveEncoder[GridLayoutPositionsStddevSampOrderBy]
        .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class GridLayoutPositionsSumOrderBy(
      val height: clue.data.Input[OrderBy] = clue.data.Ignore,
      val width:  clue.data.Input[OrderBy] = clue.data.Ignore,
      val x:      clue.data.Input[OrderBy] = clue.data.Ignore,
      val y:      clue.data.Input[OrderBy] = clue.data.Ignore
    )
    object GridLayoutPositionsSumOrderBy {
      implicit val height: monocle.Lens[GridLayoutPositionsSumOrderBy, clue.data.Input[OrderBy]] =
        monocle.macros.GenLens[GridLayoutPositionsSumOrderBy](_.height)
      implicit val width: monocle.Lens[GridLayoutPositionsSumOrderBy, clue.data.Input[OrderBy]]  =
        monocle.macros.GenLens[GridLayoutPositionsSumOrderBy](_.width)
      implicit val x: monocle.Lens[GridLayoutPositionsSumOrderBy, clue.data.Input[OrderBy]]      =
        monocle.macros.GenLens[GridLayoutPositionsSumOrderBy](_.x)
      implicit val y: monocle.Lens[GridLayoutPositionsSumOrderBy, clue.data.Input[OrderBy]]      =
        monocle.macros.GenLens[GridLayoutPositionsSumOrderBy](_.y)
      implicit val eqGridLayoutPositionsSumOrderBy: cats.Eq[GridLayoutPositionsSumOrderBy]       =
        cats.Eq.fromUniversalEquals
      implicit val showGridLayoutPositionsSumOrderBy: cats.Show[GridLayoutPositionsSumOrderBy]   =
        cats.Show.fromToString
      implicit val jsonEncoderGridLayoutPositionsSumOrderBy
        : io.circe.Encoder[GridLayoutPositionsSumOrderBy]                                        = io.circe.generic.semiauto
        .deriveEncoder[GridLayoutPositionsSumOrderBy]
        .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class GridLayoutPositionsVarPopOrderBy(
      val height: clue.data.Input[OrderBy] = clue.data.Ignore,
      val width:  clue.data.Input[OrderBy] = clue.data.Ignore,
      val x:      clue.data.Input[OrderBy] = clue.data.Ignore,
      val y:      clue.data.Input[OrderBy] = clue.data.Ignore
    )
    object GridLayoutPositionsVarPopOrderBy {
      implicit val height
        : monocle.Lens[GridLayoutPositionsVarPopOrderBy, clue.data.Input[OrderBy]]                 =
        monocle.macros.GenLens[GridLayoutPositionsVarPopOrderBy](_.height)
      implicit val width: monocle.Lens[GridLayoutPositionsVarPopOrderBy, clue.data.Input[OrderBy]] =
        monocle.macros.GenLens[GridLayoutPositionsVarPopOrderBy](_.width)
      implicit val x: monocle.Lens[GridLayoutPositionsVarPopOrderBy, clue.data.Input[OrderBy]]     =
        monocle.macros.GenLens[GridLayoutPositionsVarPopOrderBy](_.x)
      implicit val y: monocle.Lens[GridLayoutPositionsVarPopOrderBy, clue.data.Input[OrderBy]]     =
        monocle.macros.GenLens[GridLayoutPositionsVarPopOrderBy](_.y)
      implicit val eqGridLayoutPositionsVarPopOrderBy: cats.Eq[GridLayoutPositionsVarPopOrderBy]   =
        cats.Eq.fromUniversalEquals
      implicit val showGridLayoutPositionsVarPopOrderBy
        : cats.Show[GridLayoutPositionsVarPopOrderBy]                                              = cats.Show.fromToString
      implicit val jsonEncoderGridLayoutPositionsVarPopOrderBy
        : io.circe.Encoder[GridLayoutPositionsVarPopOrderBy]                                       = io.circe.generic.semiauto
        .deriveEncoder[GridLayoutPositionsVarPopOrderBy]
        .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class GridLayoutPositionsVarSampOrderBy(
      val height: clue.data.Input[OrderBy] = clue.data.Ignore,
      val width:  clue.data.Input[OrderBy] = clue.data.Ignore,
      val x:      clue.data.Input[OrderBy] = clue.data.Ignore,
      val y:      clue.data.Input[OrderBy] = clue.data.Ignore
    )
    object GridLayoutPositionsVarSampOrderBy {
      implicit val height
        : monocle.Lens[GridLayoutPositionsVarSampOrderBy, clue.data.Input[OrderBy]]                =
        monocle.macros.GenLens[GridLayoutPositionsVarSampOrderBy](_.height)
      implicit val width
        : monocle.Lens[GridLayoutPositionsVarSampOrderBy, clue.data.Input[OrderBy]]                =
        monocle.macros.GenLens[GridLayoutPositionsVarSampOrderBy](_.width)
      implicit val x: monocle.Lens[GridLayoutPositionsVarSampOrderBy, clue.data.Input[OrderBy]]    =
        monocle.macros.GenLens[GridLayoutPositionsVarSampOrderBy](_.x)
      implicit val y: monocle.Lens[GridLayoutPositionsVarSampOrderBy, clue.data.Input[OrderBy]]    =
        monocle.macros.GenLens[GridLayoutPositionsVarSampOrderBy](_.y)
      implicit val eqGridLayoutPositionsVarSampOrderBy: cats.Eq[GridLayoutPositionsVarSampOrderBy] =
        cats.Eq.fromUniversalEquals
      implicit val showGridLayoutPositionsVarSampOrderBy
        : cats.Show[GridLayoutPositionsVarSampOrderBy]                                             = cats.Show.fromToString
      implicit val jsonEncoderGridLayoutPositionsVarSampOrderBy
        : io.circe.Encoder[GridLayoutPositionsVarSampOrderBy]                                      = io.circe.generic.semiauto
        .deriveEncoder[GridLayoutPositionsVarSampOrderBy]
        .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class GridLayoutPositionsVarianceOrderBy(
      val height: clue.data.Input[OrderBy] = clue.data.Ignore,
      val width:  clue.data.Input[OrderBy] = clue.data.Ignore,
      val x:      clue.data.Input[OrderBy] = clue.data.Ignore,
      val y:      clue.data.Input[OrderBy] = clue.data.Ignore
    )
    object GridLayoutPositionsVarianceOrderBy {
      implicit val height
        : monocle.Lens[GridLayoutPositionsVarianceOrderBy, clue.data.Input[OrderBy]]             =
        monocle.macros.GenLens[GridLayoutPositionsVarianceOrderBy](_.height)
      implicit val width
        : monocle.Lens[GridLayoutPositionsVarianceOrderBy, clue.data.Input[OrderBy]]             =
        monocle.macros.GenLens[GridLayoutPositionsVarianceOrderBy](_.width)
      implicit val x: monocle.Lens[GridLayoutPositionsVarianceOrderBy, clue.data.Input[OrderBy]] =
        monocle.macros.GenLens[GridLayoutPositionsVarianceOrderBy](_.x)
      implicit val y: monocle.Lens[GridLayoutPositionsVarianceOrderBy, clue.data.Input[OrderBy]] =
        monocle.macros.GenLens[GridLayoutPositionsVarianceOrderBy](_.y)
      implicit val eqGridLayoutPositionsVarianceOrderBy
        : cats.Eq[GridLayoutPositionsVarianceOrderBy]                                            = cats.Eq.fromUniversalEquals
      implicit val showGridLayoutPositionsVarianceOrderBy
        : cats.Show[GridLayoutPositionsVarianceOrderBy]                                          = cats.Show.fromToString
      implicit val jsonEncoderGridLayoutPositionsVarianceOrderBy
        : io.circe.Encoder[GridLayoutPositionsVarianceOrderBy]                                   = io.circe.generic.semiauto
        .deriveEncoder[GridLayoutPositionsVarianceOrderBy]
        .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class IntComparisonExp(
      val _eq:      clue.data.Input[Int] = clue.data.Ignore,
      val _gt:      clue.data.Input[Int] = clue.data.Ignore,
      val _gte:     clue.data.Input[Int] = clue.data.Ignore,
      val _in:      clue.data.Input[List[Int]] = clue.data.Ignore,
      val _is_null: clue.data.Input[Boolean] = clue.data.Ignore,
      val _lt:      clue.data.Input[Int] = clue.data.Ignore,
      val _lte:     clue.data.Input[Int] = clue.data.Ignore,
      val _neq:     clue.data.Input[Int] = clue.data.Ignore,
      val _nin:     clue.data.Input[List[Int]] = clue.data.Ignore
    )
    object IntComparisonExp {
      implicit val _eq: monocle.Lens[IntComparisonExp, clue.data.Input[Int]]          =
        monocle.macros.GenLens[IntComparisonExp](_._eq)
      implicit val _gt: monocle.Lens[IntComparisonExp, clue.data.Input[Int]]          =
        monocle.macros.GenLens[IntComparisonExp](_._gt)
      implicit val _gte: monocle.Lens[IntComparisonExp, clue.data.Input[Int]]         =
        monocle.macros.GenLens[IntComparisonExp](_._gte)
      implicit val _in: monocle.Lens[IntComparisonExp, clue.data.Input[List[Int]]]    =
        monocle.macros.GenLens[IntComparisonExp](_._in)
      implicit val _is_null: monocle.Lens[IntComparisonExp, clue.data.Input[Boolean]] =
        monocle.macros.GenLens[IntComparisonExp](_._is_null)
      implicit val _lt: monocle.Lens[IntComparisonExp, clue.data.Input[Int]]          =
        monocle.macros.GenLens[IntComparisonExp](_._lt)
      implicit val _lte: monocle.Lens[IntComparisonExp, clue.data.Input[Int]]         =
        monocle.macros.GenLens[IntComparisonExp](_._lte)
      implicit val _neq: monocle.Lens[IntComparisonExp, clue.data.Input[Int]]         =
        monocle.macros.GenLens[IntComparisonExp](_._neq)
      implicit val _nin: monocle.Lens[IntComparisonExp, clue.data.Input[List[Int]]]   =
        monocle.macros.GenLens[IntComparisonExp](_._nin)
      implicit val eqIntComparisonExp: cats.Eq[IntComparisonExp]                      = cats.Eq.fromUniversalEquals
      implicit val showIntComparisonExp: cats.Show[IntComparisonExp]                  = cats.Show.fromToString
      implicit val jsonEncoderIntComparisonExp: io.circe.Encoder[IntComparisonExp]    =
        io.circe.generic.semiauto
          .deriveEncoder[IntComparisonExp]
          .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class LucumaTargetAggregateOrderBy(
      val count: clue.data.Input[OrderBy] = clue.data.Ignore,
      val max:   clue.data.Input[LucumaTargetMaxOrderBy] = clue.data.Ignore,
      val min:   clue.data.Input[LucumaTargetMinOrderBy] = clue.data.Ignore
    )
    object LucumaTargetAggregateOrderBy {
      implicit val count: monocle.Lens[LucumaTargetAggregateOrderBy, clue.data.Input[OrderBy]] =
        monocle.macros.GenLens[LucumaTargetAggregateOrderBy](_.count)
      implicit val max
        : monocle.Lens[LucumaTargetAggregateOrderBy, clue.data.Input[LucumaTargetMaxOrderBy]]  =
        monocle.macros.GenLens[LucumaTargetAggregateOrderBy](_.max)
      implicit val min
        : monocle.Lens[LucumaTargetAggregateOrderBy, clue.data.Input[LucumaTargetMinOrderBy]]  =
        monocle.macros.GenLens[LucumaTargetAggregateOrderBy](_.min)
      implicit val eqLucumaTargetAggregateOrderBy: cats.Eq[LucumaTargetAggregateOrderBy]       =
        cats.Eq.fromUniversalEquals
      implicit val showLucumaTargetAggregateOrderBy: cats.Show[LucumaTargetAggregateOrderBy]   =
        cats.Show.fromToString
      implicit val jsonEncoderLucumaTargetAggregateOrderBy
        : io.circe.Encoder[LucumaTargetAggregateOrderBy]                                       = io.circe.generic.semiauto
        .deriveEncoder[LucumaTargetAggregateOrderBy]
        .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class LucumaTargetArrRelInsertInput(
      val data:        List[LucumaTargetInsertInput],
      val on_conflict: clue.data.Input[LucumaTargetOnConflict] = clue.data.Ignore
    )
    object LucumaTargetArrRelInsertInput {
      implicit val data
        : monocle.Lens[LucumaTargetArrRelInsertInput, List[LucumaTargetInsertInput]]           =
        monocle.macros.GenLens[LucumaTargetArrRelInsertInput](_.data)
      implicit val on_conflict
        : monocle.Lens[LucumaTargetArrRelInsertInput, clue.data.Input[LucumaTargetOnConflict]] =
        monocle.macros.GenLens[LucumaTargetArrRelInsertInput](_.on_conflict)
      implicit val eqLucumaTargetArrRelInsertInput: cats.Eq[LucumaTargetArrRelInsertInput]     =
        cats.Eq.fromUniversalEquals
      implicit val showLucumaTargetArrRelInsertInput: cats.Show[LucumaTargetArrRelInsertInput] =
        cats.Show.fromToString
      implicit val jsonEncoderLucumaTargetArrRelInsertInput
        : io.circe.Encoder[LucumaTargetArrRelInsertInput]                                      = io.circe.generic.semiauto
        .deriveEncoder[LucumaTargetArrRelInsertInput]
        .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class LucumaTargetBoolExp(
      val _and:                      clue.data.Input[List[clue.data.Input[LucumaTargetBoolExp]]] = clue.data.Ignore,
      val _not:                      clue.data.Input[LucumaTargetBoolExp] = clue.data.Ignore,
      val _or:                       clue.data.Input[List[clue.data.Input[LucumaTargetBoolExp]]] = clue.data.Ignore,
      val lucuma_target_preferences: clue.data.Input[LucumaTargetPreferencesBoolExp] =
        clue.data.Ignore,
      val target_id:                 clue.data.Input[StringComparisonExp] = clue.data.Ignore
    )
    object LucumaTargetBoolExp {
      implicit val _and: monocle.Lens[LucumaTargetBoolExp, clue.data.Input[List[
        clue.data.Input[LucumaTargetBoolExp]
      ]]]                                                                                        = monocle.macros.GenLens[LucumaTargetBoolExp](_._and)
      implicit val _not: monocle.Lens[LucumaTargetBoolExp, clue.data.Input[LucumaTargetBoolExp]] =
        monocle.macros.GenLens[LucumaTargetBoolExp](_._not)
      implicit val _or: monocle.Lens[LucumaTargetBoolExp, clue.data.Input[List[
        clue.data.Input[LucumaTargetBoolExp]
      ]]]                                                                                        = monocle.macros.GenLens[LucumaTargetBoolExp](_._or)
      implicit val lucuma_target_preferences
        : monocle.Lens[LucumaTargetBoolExp, clue.data.Input[LucumaTargetPreferencesBoolExp]]     =
        monocle.macros.GenLens[LucumaTargetBoolExp](_.lucuma_target_preferences)
      implicit val target_id
        : monocle.Lens[LucumaTargetBoolExp, clue.data.Input[StringComparisonExp]]                =
        monocle.macros.GenLens[LucumaTargetBoolExp](_.target_id)
      implicit val eqLucumaTargetBoolExp: cats.Eq[LucumaTargetBoolExp]                           = cats.Eq.fromUniversalEquals
      implicit val showLucumaTargetBoolExp: cats.Show[LucumaTargetBoolExp]                       = cats.Show.fromToString
      implicit val jsonEncoderLucumaTargetBoolExp: io.circe.Encoder[LucumaTargetBoolExp]         =
        io.circe.generic.semiauto
          .deriveEncoder[LucumaTargetBoolExp]
          .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class LucumaTargetInsertInput(
      val lucuma_target_preferences: clue.data.Input[LucumaTargetPreferencesArrRelInsertInput] =
        clue.data.Ignore,
      val target_id:                 clue.data.Input[String] = clue.data.Ignore
    )
    object LucumaTargetInsertInput {
      implicit val lucuma_target_preferences: monocle.Lens[LucumaTargetInsertInput, clue.data.Input[
        LucumaTargetPreferencesArrRelInsertInput
      ]]                                                                                         = monocle.macros.GenLens[LucumaTargetInsertInput](_.lucuma_target_preferences)
      implicit val target_id: monocle.Lens[LucumaTargetInsertInput, clue.data.Input[String]]     =
        monocle.macros.GenLens[LucumaTargetInsertInput](_.target_id)
      implicit val eqLucumaTargetInsertInput: cats.Eq[LucumaTargetInsertInput]                   =
        cats.Eq.fromUniversalEquals
      implicit val showLucumaTargetInsertInput: cats.Show[LucumaTargetInsertInput]               =
        cats.Show.fromToString
      implicit val jsonEncoderLucumaTargetInsertInput: io.circe.Encoder[LucumaTargetInsertInput] =
        io.circe.generic.semiauto
          .deriveEncoder[LucumaTargetInsertInput]
          .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class LucumaTargetMaxOrderBy(val target_id: clue.data.Input[OrderBy] = clue.data.Ignore)
    object LucumaTargetMaxOrderBy {
      implicit val target_id: monocle.Lens[LucumaTargetMaxOrderBy, clue.data.Input[OrderBy]]   =
        monocle.macros.GenLens[LucumaTargetMaxOrderBy](_.target_id)
      implicit val eqLucumaTargetMaxOrderBy: cats.Eq[LucumaTargetMaxOrderBy]                   =
        cats.Eq.fromUniversalEquals
      implicit val showLucumaTargetMaxOrderBy: cats.Show[LucumaTargetMaxOrderBy]               =
        cats.Show.fromToString
      implicit val jsonEncoderLucumaTargetMaxOrderBy: io.circe.Encoder[LucumaTargetMaxOrderBy] =
        io.circe.generic.semiauto
          .deriveEncoder[LucumaTargetMaxOrderBy]
          .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class LucumaTargetMinOrderBy(val target_id: clue.data.Input[OrderBy] = clue.data.Ignore)
    object LucumaTargetMinOrderBy {
      implicit val target_id: monocle.Lens[LucumaTargetMinOrderBy, clue.data.Input[OrderBy]]   =
        monocle.macros.GenLens[LucumaTargetMinOrderBy](_.target_id)
      implicit val eqLucumaTargetMinOrderBy: cats.Eq[LucumaTargetMinOrderBy]                   =
        cats.Eq.fromUniversalEquals
      implicit val showLucumaTargetMinOrderBy: cats.Show[LucumaTargetMinOrderBy]               =
        cats.Show.fromToString
      implicit val jsonEncoderLucumaTargetMinOrderBy: io.circe.Encoder[LucumaTargetMinOrderBy] =
        io.circe.generic.semiauto
          .deriveEncoder[LucumaTargetMinOrderBy]
          .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class LucumaTargetObjRelInsertInput(
      val data:        LucumaTargetInsertInput,
      val on_conflict: clue.data.Input[LucumaTargetOnConflict] = clue.data.Ignore
    )
    object LucumaTargetObjRelInsertInput {
      implicit val data: monocle.Lens[LucumaTargetObjRelInsertInput, LucumaTargetInsertInput]  =
        monocle.macros.GenLens[LucumaTargetObjRelInsertInput](_.data)
      implicit val on_conflict
        : monocle.Lens[LucumaTargetObjRelInsertInput, clue.data.Input[LucumaTargetOnConflict]] =
        monocle.macros.GenLens[LucumaTargetObjRelInsertInput](_.on_conflict)
      implicit val eqLucumaTargetObjRelInsertInput: cats.Eq[LucumaTargetObjRelInsertInput]     =
        cats.Eq.fromUniversalEquals
      implicit val showLucumaTargetObjRelInsertInput: cats.Show[LucumaTargetObjRelInsertInput] =
        cats.Show.fromToString
      implicit val jsonEncoderLucumaTargetObjRelInsertInput
        : io.circe.Encoder[LucumaTargetObjRelInsertInput]                                      = io.circe.generic.semiauto
        .deriveEncoder[LucumaTargetObjRelInsertInput]
        .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class LucumaTargetOnConflict(
      val constraint:     LucumaTargetConstraint,
      val update_columns: List[LucumaTargetUpdateColumn],
      val where:          clue.data.Input[LucumaTargetBoolExp] = clue.data.Ignore
    )
    object LucumaTargetOnConflict {
      implicit val constraint: monocle.Lens[LucumaTargetOnConflict, LucumaTargetConstraint]    =
        monocle.macros.GenLens[LucumaTargetOnConflict](_.constraint)
      implicit val update_columns
        : monocle.Lens[LucumaTargetOnConflict, List[LucumaTargetUpdateColumn]]                 =
        monocle.macros.GenLens[LucumaTargetOnConflict](_.update_columns)
      implicit val where
        : monocle.Lens[LucumaTargetOnConflict, clue.data.Input[LucumaTargetBoolExp]]           =
        monocle.macros.GenLens[LucumaTargetOnConflict](_.where)
      implicit val eqLucumaTargetOnConflict: cats.Eq[LucumaTargetOnConflict]                   =
        cats.Eq.fromUniversalEquals
      implicit val showLucumaTargetOnConflict: cats.Show[LucumaTargetOnConflict]               =
        cats.Show.fromToString
      implicit val jsonEncoderLucumaTargetOnConflict: io.circe.Encoder[LucumaTargetOnConflict] =
        io.circe.generic.semiauto
          .deriveEncoder[LucumaTargetOnConflict]
          .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class LucumaTargetOrderBy(
      val lucuma_target_preferences_aggregate: clue.data.Input[
        LucumaTargetPreferencesAggregateOrderBy
      ] = clue.data.Ignore,
      val target_id:                           clue.data.Input[OrderBy] = clue.data.Ignore
    )
    object LucumaTargetOrderBy {
      implicit val lucuma_target_preferences_aggregate: monocle.Lens[
        LucumaTargetOrderBy,
        clue.data.Input[LucumaTargetPreferencesAggregateOrderBy]
      ]                                                                                   = monocle.macros.GenLens[LucumaTargetOrderBy](_.lucuma_target_preferences_aggregate)
      implicit val target_id: monocle.Lens[LucumaTargetOrderBy, clue.data.Input[OrderBy]] =
        monocle.macros.GenLens[LucumaTargetOrderBy](_.target_id)
      implicit val eqLucumaTargetOrderBy: cats.Eq[LucumaTargetOrderBy]                    = cats.Eq.fromUniversalEquals
      implicit val showLucumaTargetOrderBy: cats.Show[LucumaTargetOrderBy]                = cats.Show.fromToString
      implicit val jsonEncoderLucumaTargetOrderBy: io.circe.Encoder[LucumaTargetOrderBy]  =
        io.circe.generic.semiauto
          .deriveEncoder[LucumaTargetOrderBy]
          .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class LucumaTargetPkColumnsInput(val target_id: String)
    object LucumaTargetPkColumnsInput {
      implicit val target_id: monocle.Lens[LucumaTargetPkColumnsInput, String]           =
        monocle.macros.GenLens[LucumaTargetPkColumnsInput](_.target_id)
      implicit val eqLucumaTargetPkColumnsInput: cats.Eq[LucumaTargetPkColumnsInput]     =
        cats.Eq.fromUniversalEquals
      implicit val showLucumaTargetPkColumnsInput: cats.Show[LucumaTargetPkColumnsInput] =
        cats.Show.fromToString
      implicit val jsonEncoderLucumaTargetPkColumnsInput
        : io.circe.Encoder[LucumaTargetPkColumnsInput]                                   = io.circe.generic.semiauto
        .deriveEncoder[LucumaTargetPkColumnsInput]
        .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class LucumaTargetPreferencesAggregateOrderBy(
      val avg:         clue.data.Input[LucumaTargetPreferencesAvgOrderBy] = clue.data.Ignore,
      val count:       clue.data.Input[OrderBy] = clue.data.Ignore,
      val max:         clue.data.Input[LucumaTargetPreferencesMaxOrderBy] = clue.data.Ignore,
      val min:         clue.data.Input[LucumaTargetPreferencesMinOrderBy] = clue.data.Ignore,
      val stddev:      clue.data.Input[LucumaTargetPreferencesStddevOrderBy] = clue.data.Ignore,
      val stddev_pop:  clue.data.Input[LucumaTargetPreferencesStddevPopOrderBy] = clue.data.Ignore,
      val stddev_samp: clue.data.Input[LucumaTargetPreferencesStddevSampOrderBy] = clue.data.Ignore,
      val sum:         clue.data.Input[LucumaTargetPreferencesSumOrderBy] = clue.data.Ignore,
      val var_pop:     clue.data.Input[LucumaTargetPreferencesVarPopOrderBy] = clue.data.Ignore,
      val var_samp:    clue.data.Input[LucumaTargetPreferencesVarSampOrderBy] = clue.data.Ignore,
      val variance:    clue.data.Input[LucumaTargetPreferencesVarianceOrderBy] = clue.data.Ignore
    )
    object LucumaTargetPreferencesAggregateOrderBy {
      implicit val avg: monocle.Lens[LucumaTargetPreferencesAggregateOrderBy, clue.data.Input[
        LucumaTargetPreferencesAvgOrderBy
      ]]                                                                                  = monocle.macros.GenLens[LucumaTargetPreferencesAggregateOrderBy](_.avg)
      implicit val count
        : monocle.Lens[LucumaTargetPreferencesAggregateOrderBy, clue.data.Input[OrderBy]] =
        monocle.macros.GenLens[LucumaTargetPreferencesAggregateOrderBy](_.count)
      implicit val max: monocle.Lens[LucumaTargetPreferencesAggregateOrderBy, clue.data.Input[
        LucumaTargetPreferencesMaxOrderBy
      ]]                                                                                  = monocle.macros.GenLens[LucumaTargetPreferencesAggregateOrderBy](_.max)
      implicit val min: monocle.Lens[LucumaTargetPreferencesAggregateOrderBy, clue.data.Input[
        LucumaTargetPreferencesMinOrderBy
      ]]                                                                                  = monocle.macros.GenLens[LucumaTargetPreferencesAggregateOrderBy](_.min)
      implicit val stddev: monocle.Lens[LucumaTargetPreferencesAggregateOrderBy, clue.data.Input[
        LucumaTargetPreferencesStddevOrderBy
      ]]                                                                                  = monocle.macros.GenLens[LucumaTargetPreferencesAggregateOrderBy](_.stddev)
      implicit val stddev_pop: monocle.Lens[
        LucumaTargetPreferencesAggregateOrderBy,
        clue.data.Input[LucumaTargetPreferencesStddevPopOrderBy]
      ]                                                                                   = monocle.macros.GenLens[LucumaTargetPreferencesAggregateOrderBy](_.stddev_pop)
      implicit val stddev_samp: monocle.Lens[
        LucumaTargetPreferencesAggregateOrderBy,
        clue.data.Input[LucumaTargetPreferencesStddevSampOrderBy]
      ]                                                                                   = monocle.macros.GenLens[LucumaTargetPreferencesAggregateOrderBy](_.stddev_samp)
      implicit val sum: monocle.Lens[LucumaTargetPreferencesAggregateOrderBy, clue.data.Input[
        LucumaTargetPreferencesSumOrderBy
      ]]                                                                                  = monocle.macros.GenLens[LucumaTargetPreferencesAggregateOrderBy](_.sum)
      implicit val var_pop: monocle.Lens[LucumaTargetPreferencesAggregateOrderBy, clue.data.Input[
        LucumaTargetPreferencesVarPopOrderBy
      ]]                                                                                  = monocle.macros.GenLens[LucumaTargetPreferencesAggregateOrderBy](_.var_pop)
      implicit val var_samp: monocle.Lens[LucumaTargetPreferencesAggregateOrderBy, clue.data.Input[
        LucumaTargetPreferencesVarSampOrderBy
      ]]                                                                                  = monocle.macros.GenLens[LucumaTargetPreferencesAggregateOrderBy](_.var_samp)
      implicit val variance: monocle.Lens[LucumaTargetPreferencesAggregateOrderBy, clue.data.Input[
        LucumaTargetPreferencesVarianceOrderBy
      ]]                                                                                  = monocle.macros.GenLens[LucumaTargetPreferencesAggregateOrderBy](_.variance)
      implicit val eqLucumaTargetPreferencesAggregateOrderBy
        : cats.Eq[LucumaTargetPreferencesAggregateOrderBy]                                = cats.Eq.fromUniversalEquals
      implicit val showLucumaTargetPreferencesAggregateOrderBy
        : cats.Show[LucumaTargetPreferencesAggregateOrderBy]                              = cats.Show.fromToString
      implicit val jsonEncoderLucumaTargetPreferencesAggregateOrderBy
        : io.circe.Encoder[LucumaTargetPreferencesAggregateOrderBy]                       = io.circe.generic.semiauto
        .deriveEncoder[LucumaTargetPreferencesAggregateOrderBy]
        .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class LucumaTargetPreferencesArrRelInsertInput(
      val data:        List[LucumaTargetPreferencesInsertInput],
      val on_conflict: clue.data.Input[LucumaTargetPreferencesOnConflict] = clue.data.Ignore
    )
    object LucumaTargetPreferencesArrRelInsertInput {
      implicit val data: monocle.Lens[LucumaTargetPreferencesArrRelInsertInput, List[
        LucumaTargetPreferencesInsertInput
      ]]                                                             = monocle.macros.GenLens[LucumaTargetPreferencesArrRelInsertInput](_.data)
      implicit val on_conflict: monocle.Lens[
        LucumaTargetPreferencesArrRelInsertInput,
        clue.data.Input[LucumaTargetPreferencesOnConflict]
      ]                                                              = monocle.macros.GenLens[LucumaTargetPreferencesArrRelInsertInput](_.on_conflict)
      implicit val eqLucumaTargetPreferencesArrRelInsertInput
        : cats.Eq[LucumaTargetPreferencesArrRelInsertInput]          = cats.Eq.fromUniversalEquals
      implicit val showLucumaTargetPreferencesArrRelInsertInput
        : cats.Show[LucumaTargetPreferencesArrRelInsertInput]        = cats.Show.fromToString
      implicit val jsonEncoderLucumaTargetPreferencesArrRelInsertInput
        : io.circe.Encoder[LucumaTargetPreferencesArrRelInsertInput] = io.circe.generic.semiauto
        .deriveEncoder[LucumaTargetPreferencesArrRelInsertInput]
        .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class LucumaTargetPreferencesAvgOrderBy(
      val fov: clue.data.Input[OrderBy] = clue.data.Ignore
    )
    object LucumaTargetPreferencesAvgOrderBy {
      implicit val fov: monocle.Lens[LucumaTargetPreferencesAvgOrderBy, clue.data.Input[OrderBy]]  =
        monocle.macros.GenLens[LucumaTargetPreferencesAvgOrderBy](_.fov)
      implicit val eqLucumaTargetPreferencesAvgOrderBy: cats.Eq[LucumaTargetPreferencesAvgOrderBy] =
        cats.Eq.fromUniversalEquals
      implicit val showLucumaTargetPreferencesAvgOrderBy
        : cats.Show[LucumaTargetPreferencesAvgOrderBy]                                             = cats.Show.fromToString
      implicit val jsonEncoderLucumaTargetPreferencesAvgOrderBy
        : io.circe.Encoder[LucumaTargetPreferencesAvgOrderBy]                                      = io.circe.generic.semiauto
        .deriveEncoder[LucumaTargetPreferencesAvgOrderBy]
        .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class LucumaTargetPreferencesBoolExp(
      val _and:          clue.data.Input[List[clue.data.Input[LucumaTargetPreferencesBoolExp]]] =
        clue.data.Ignore,
      val _not:          clue.data.Input[LucumaTargetPreferencesBoolExp] = clue.data.Ignore,
      val _or:           clue.data.Input[List[clue.data.Input[LucumaTargetPreferencesBoolExp]]] =
        clue.data.Ignore,
      val fov:           clue.data.Input[BigintComparisonExp] = clue.data.Ignore,
      val lucuma_target: clue.data.Input[LucumaTargetBoolExp] = clue.data.Ignore,
      val target_id:     clue.data.Input[StringComparisonExp] = clue.data.Ignore,
      val user_id:       clue.data.Input[StringComparisonExp] = clue.data.Ignore
    )
    object LucumaTargetPreferencesBoolExp {
      implicit val _and: monocle.Lens[LucumaTargetPreferencesBoolExp, clue.data.Input[List[
        clue.data.Input[LucumaTargetPreferencesBoolExp]
      ]]]                                                                                        = monocle.macros.GenLens[LucumaTargetPreferencesBoolExp](_._and)
      implicit val _not: monocle.Lens[LucumaTargetPreferencesBoolExp, clue.data.Input[
        LucumaTargetPreferencesBoolExp
      ]]                                                                                         = monocle.macros.GenLens[LucumaTargetPreferencesBoolExp](_._not)
      implicit val _or: monocle.Lens[LucumaTargetPreferencesBoolExp, clue.data.Input[List[
        clue.data.Input[LucumaTargetPreferencesBoolExp]
      ]]]                                                                                        = monocle.macros.GenLens[LucumaTargetPreferencesBoolExp](_._or)
      implicit val fov
        : monocle.Lens[LucumaTargetPreferencesBoolExp, clue.data.Input[BigintComparisonExp]]     =
        monocle.macros.GenLens[LucumaTargetPreferencesBoolExp](_.fov)
      implicit val lucuma_target
        : monocle.Lens[LucumaTargetPreferencesBoolExp, clue.data.Input[LucumaTargetBoolExp]]     =
        monocle.macros.GenLens[LucumaTargetPreferencesBoolExp](_.lucuma_target)
      implicit val target_id
        : monocle.Lens[LucumaTargetPreferencesBoolExp, clue.data.Input[StringComparisonExp]]     =
        monocle.macros.GenLens[LucumaTargetPreferencesBoolExp](_.target_id)
      implicit val user_id
        : monocle.Lens[LucumaTargetPreferencesBoolExp, clue.data.Input[StringComparisonExp]]     =
        monocle.macros.GenLens[LucumaTargetPreferencesBoolExp](_.user_id)
      implicit val eqLucumaTargetPreferencesBoolExp: cats.Eq[LucumaTargetPreferencesBoolExp]     =
        cats.Eq.fromUniversalEquals
      implicit val showLucumaTargetPreferencesBoolExp: cats.Show[LucumaTargetPreferencesBoolExp] =
        cats.Show.fromToString
      implicit val jsonEncoderLucumaTargetPreferencesBoolExp
        : io.circe.Encoder[LucumaTargetPreferencesBoolExp]                                       = io.circe.generic.semiauto
        .deriveEncoder[LucumaTargetPreferencesBoolExp]
        .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class LucumaTargetPreferencesIncInput(val fov: clue.data.Input[Bigint] = clue.data.Ignore)
    object LucumaTargetPreferencesIncInput {
      implicit val fov: monocle.Lens[LucumaTargetPreferencesIncInput, clue.data.Input[Bigint]]     =
        monocle.macros.GenLens[LucumaTargetPreferencesIncInput](_.fov)
      implicit val eqLucumaTargetPreferencesIncInput: cats.Eq[LucumaTargetPreferencesIncInput]     =
        cats.Eq.fromUniversalEquals
      implicit val showLucumaTargetPreferencesIncInput: cats.Show[LucumaTargetPreferencesIncInput] =
        cats.Show.fromToString
      implicit val jsonEncoderLucumaTargetPreferencesIncInput
        : io.circe.Encoder[LucumaTargetPreferencesIncInput]                                        = io.circe.generic.semiauto
        .deriveEncoder[LucumaTargetPreferencesIncInput]
        .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class LucumaTargetPreferencesInsertInput(
      val fov:           clue.data.Input[Bigint] = clue.data.Ignore,
      val lucuma_target: clue.data.Input[LucumaTargetObjRelInsertInput] = clue.data.Ignore,
      val target_id:     clue.data.Input[String] = clue.data.Ignore,
      val user_id:       clue.data.Input[String] = clue.data.Ignore
    )
    object LucumaTargetPreferencesInsertInput {
      implicit val fov: monocle.Lens[LucumaTargetPreferencesInsertInput, clue.data.Input[Bigint]] =
        monocle.macros.GenLens[LucumaTargetPreferencesInsertInput](_.fov)
      implicit val lucuma_target: monocle.Lens[LucumaTargetPreferencesInsertInput, clue.data.Input[
        LucumaTargetObjRelInsertInput
      ]]                                                                                          = monocle.macros.GenLens[LucumaTargetPreferencesInsertInput](_.lucuma_target)
      implicit val target_id
        : monocle.Lens[LucumaTargetPreferencesInsertInput, clue.data.Input[String]]               =
        monocle.macros.GenLens[LucumaTargetPreferencesInsertInput](_.target_id)
      implicit val user_id
        : monocle.Lens[LucumaTargetPreferencesInsertInput, clue.data.Input[String]]               =
        monocle.macros.GenLens[LucumaTargetPreferencesInsertInput](_.user_id)
      implicit val eqLucumaTargetPreferencesInsertInput
        : cats.Eq[LucumaTargetPreferencesInsertInput]                                             = cats.Eq.fromUniversalEquals
      implicit val showLucumaTargetPreferencesInsertInput
        : cats.Show[LucumaTargetPreferencesInsertInput]                                           = cats.Show.fromToString
      implicit val jsonEncoderLucumaTargetPreferencesInsertInput
        : io.circe.Encoder[LucumaTargetPreferencesInsertInput]                                    = io.circe.generic.semiauto
        .deriveEncoder[LucumaTargetPreferencesInsertInput]
        .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class LucumaTargetPreferencesMaxOrderBy(
      val fov:       clue.data.Input[OrderBy] = clue.data.Ignore,
      val target_id: clue.data.Input[OrderBy] = clue.data.Ignore,
      val user_id:   clue.data.Input[OrderBy] = clue.data.Ignore
    )
    object LucumaTargetPreferencesMaxOrderBy {
      implicit val fov: monocle.Lens[LucumaTargetPreferencesMaxOrderBy, clue.data.Input[OrderBy]]  =
        monocle.macros.GenLens[LucumaTargetPreferencesMaxOrderBy](_.fov)
      implicit val target_id
        : monocle.Lens[LucumaTargetPreferencesMaxOrderBy, clue.data.Input[OrderBy]]                =
        monocle.macros.GenLens[LucumaTargetPreferencesMaxOrderBy](_.target_id)
      implicit val user_id
        : monocle.Lens[LucumaTargetPreferencesMaxOrderBy, clue.data.Input[OrderBy]]                =
        monocle.macros.GenLens[LucumaTargetPreferencesMaxOrderBy](_.user_id)
      implicit val eqLucumaTargetPreferencesMaxOrderBy: cats.Eq[LucumaTargetPreferencesMaxOrderBy] =
        cats.Eq.fromUniversalEquals
      implicit val showLucumaTargetPreferencesMaxOrderBy
        : cats.Show[LucumaTargetPreferencesMaxOrderBy]                                             = cats.Show.fromToString
      implicit val jsonEncoderLucumaTargetPreferencesMaxOrderBy
        : io.circe.Encoder[LucumaTargetPreferencesMaxOrderBy]                                      = io.circe.generic.semiauto
        .deriveEncoder[LucumaTargetPreferencesMaxOrderBy]
        .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class LucumaTargetPreferencesMinOrderBy(
      val fov:       clue.data.Input[OrderBy] = clue.data.Ignore,
      val target_id: clue.data.Input[OrderBy] = clue.data.Ignore,
      val user_id:   clue.data.Input[OrderBy] = clue.data.Ignore
    )
    object LucumaTargetPreferencesMinOrderBy {
      implicit val fov: monocle.Lens[LucumaTargetPreferencesMinOrderBy, clue.data.Input[OrderBy]]  =
        monocle.macros.GenLens[LucumaTargetPreferencesMinOrderBy](_.fov)
      implicit val target_id
        : monocle.Lens[LucumaTargetPreferencesMinOrderBy, clue.data.Input[OrderBy]]                =
        monocle.macros.GenLens[LucumaTargetPreferencesMinOrderBy](_.target_id)
      implicit val user_id
        : monocle.Lens[LucumaTargetPreferencesMinOrderBy, clue.data.Input[OrderBy]]                =
        monocle.macros.GenLens[LucumaTargetPreferencesMinOrderBy](_.user_id)
      implicit val eqLucumaTargetPreferencesMinOrderBy: cats.Eq[LucumaTargetPreferencesMinOrderBy] =
        cats.Eq.fromUniversalEquals
      implicit val showLucumaTargetPreferencesMinOrderBy
        : cats.Show[LucumaTargetPreferencesMinOrderBy]                                             = cats.Show.fromToString
      implicit val jsonEncoderLucumaTargetPreferencesMinOrderBy
        : io.circe.Encoder[LucumaTargetPreferencesMinOrderBy]                                      = io.circe.generic.semiauto
        .deriveEncoder[LucumaTargetPreferencesMinOrderBy]
        .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class LucumaTargetPreferencesObjRelInsertInput(
      val data:        LucumaTargetPreferencesInsertInput,
      val on_conflict: clue.data.Input[LucumaTargetPreferencesOnConflict] = clue.data.Ignore
    )
    object LucumaTargetPreferencesObjRelInsertInput {
      implicit val data: monocle.Lens[
        LucumaTargetPreferencesObjRelInsertInput,
        LucumaTargetPreferencesInsertInput
      ]                                                              = monocle.macros.GenLens[LucumaTargetPreferencesObjRelInsertInput](_.data)
      implicit val on_conflict: monocle.Lens[
        LucumaTargetPreferencesObjRelInsertInput,
        clue.data.Input[LucumaTargetPreferencesOnConflict]
      ]                                                              = monocle.macros.GenLens[LucumaTargetPreferencesObjRelInsertInput](_.on_conflict)
      implicit val eqLucumaTargetPreferencesObjRelInsertInput
        : cats.Eq[LucumaTargetPreferencesObjRelInsertInput]          = cats.Eq.fromUniversalEquals
      implicit val showLucumaTargetPreferencesObjRelInsertInput
        : cats.Show[LucumaTargetPreferencesObjRelInsertInput]        = cats.Show.fromToString
      implicit val jsonEncoderLucumaTargetPreferencesObjRelInsertInput
        : io.circe.Encoder[LucumaTargetPreferencesObjRelInsertInput] = io.circe.generic.semiauto
        .deriveEncoder[LucumaTargetPreferencesObjRelInsertInput]
        .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class LucumaTargetPreferencesOnConflict(
      val constraint:     LucumaTargetPreferencesConstraint,
      val update_columns: List[LucumaTargetPreferencesUpdateColumn],
      val where:          clue.data.Input[LucumaTargetPreferencesBoolExp] = clue.data.Ignore
    )
    object LucumaTargetPreferencesOnConflict {
      implicit val constraint
        : monocle.Lens[LucumaTargetPreferencesOnConflict, LucumaTargetPreferencesConstraint]       =
        monocle.macros.GenLens[LucumaTargetPreferencesOnConflict](_.constraint)
      implicit val update_columns: monocle.Lens[LucumaTargetPreferencesOnConflict, List[
        LucumaTargetPreferencesUpdateColumn
      ]]                                                                                           = monocle.macros.GenLens[LucumaTargetPreferencesOnConflict](_.update_columns)
      implicit val where: monocle.Lens[LucumaTargetPreferencesOnConflict, clue.data.Input[
        LucumaTargetPreferencesBoolExp
      ]]                                                                                           = monocle.macros.GenLens[LucumaTargetPreferencesOnConflict](_.where)
      implicit val eqLucumaTargetPreferencesOnConflict: cats.Eq[LucumaTargetPreferencesOnConflict] =
        cats.Eq.fromUniversalEquals
      implicit val showLucumaTargetPreferencesOnConflict
        : cats.Show[LucumaTargetPreferencesOnConflict]                                             = cats.Show.fromToString
      implicit val jsonEncoderLucumaTargetPreferencesOnConflict
        : io.circe.Encoder[LucumaTargetPreferencesOnConflict]                                      = io.circe.generic.semiauto
        .deriveEncoder[LucumaTargetPreferencesOnConflict]
        .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class LucumaTargetPreferencesOrderBy(
      val fov:           clue.data.Input[OrderBy] = clue.data.Ignore,
      val lucuma_target: clue.data.Input[LucumaTargetOrderBy] = clue.data.Ignore,
      val target_id:     clue.data.Input[OrderBy] = clue.data.Ignore,
      val user_id:       clue.data.Input[OrderBy] = clue.data.Ignore
    )
    object LucumaTargetPreferencesOrderBy {
      implicit val fov: monocle.Lens[LucumaTargetPreferencesOrderBy, clue.data.Input[OrderBy]]     =
        monocle.macros.GenLens[LucumaTargetPreferencesOrderBy](_.fov)
      implicit val lucuma_target
        : monocle.Lens[LucumaTargetPreferencesOrderBy, clue.data.Input[LucumaTargetOrderBy]]       =
        monocle.macros.GenLens[LucumaTargetPreferencesOrderBy](_.lucuma_target)
      implicit val target_id
        : monocle.Lens[LucumaTargetPreferencesOrderBy, clue.data.Input[OrderBy]]                   =
        monocle.macros.GenLens[LucumaTargetPreferencesOrderBy](_.target_id)
      implicit val user_id: monocle.Lens[LucumaTargetPreferencesOrderBy, clue.data.Input[OrderBy]] =
        monocle.macros.GenLens[LucumaTargetPreferencesOrderBy](_.user_id)
      implicit val eqLucumaTargetPreferencesOrderBy: cats.Eq[LucumaTargetPreferencesOrderBy]       =
        cats.Eq.fromUniversalEquals
      implicit val showLucumaTargetPreferencesOrderBy: cats.Show[LucumaTargetPreferencesOrderBy]   =
        cats.Show.fromToString
      implicit val jsonEncoderLucumaTargetPreferencesOrderBy
        : io.circe.Encoder[LucumaTargetPreferencesOrderBy]                                         = io.circe.generic.semiauto
        .deriveEncoder[LucumaTargetPreferencesOrderBy]
        .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class LucumaTargetPreferencesPkColumnsInput(val target_id: String, val user_id: String)
    object LucumaTargetPreferencesPkColumnsInput {
      implicit val target_id: monocle.Lens[LucumaTargetPreferencesPkColumnsInput, String] =
        monocle.macros.GenLens[LucumaTargetPreferencesPkColumnsInput](_.target_id)
      implicit val user_id: monocle.Lens[LucumaTargetPreferencesPkColumnsInput, String]   =
        monocle.macros.GenLens[LucumaTargetPreferencesPkColumnsInput](_.user_id)
      implicit val eqLucumaTargetPreferencesPkColumnsInput
        : cats.Eq[LucumaTargetPreferencesPkColumnsInput]                                  = cats.Eq.fromUniversalEquals
      implicit val showLucumaTargetPreferencesPkColumnsInput
        : cats.Show[LucumaTargetPreferencesPkColumnsInput]                                = cats.Show.fromToString
      implicit val jsonEncoderLucumaTargetPreferencesPkColumnsInput
        : io.circe.Encoder[LucumaTargetPreferencesPkColumnsInput]                         = io.circe.generic.semiauto
        .deriveEncoder[LucumaTargetPreferencesPkColumnsInput]
        .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class LucumaTargetPreferencesSetInput(
      val fov:       clue.data.Input[Bigint] = clue.data.Ignore,
      val target_id: clue.data.Input[String] = clue.data.Ignore,
      val user_id:   clue.data.Input[String] = clue.data.Ignore
    )
    object LucumaTargetPreferencesSetInput {
      implicit val fov: monocle.Lens[LucumaTargetPreferencesSetInput, clue.data.Input[Bigint]]     =
        monocle.macros.GenLens[LucumaTargetPreferencesSetInput](_.fov)
      implicit val target_id
        : monocle.Lens[LucumaTargetPreferencesSetInput, clue.data.Input[String]]                   =
        monocle.macros.GenLens[LucumaTargetPreferencesSetInput](_.target_id)
      implicit val user_id: monocle.Lens[LucumaTargetPreferencesSetInput, clue.data.Input[String]] =
        monocle.macros.GenLens[LucumaTargetPreferencesSetInput](_.user_id)
      implicit val eqLucumaTargetPreferencesSetInput: cats.Eq[LucumaTargetPreferencesSetInput]     =
        cats.Eq.fromUniversalEquals
      implicit val showLucumaTargetPreferencesSetInput: cats.Show[LucumaTargetPreferencesSetInput] =
        cats.Show.fromToString
      implicit val jsonEncoderLucumaTargetPreferencesSetInput
        : io.circe.Encoder[LucumaTargetPreferencesSetInput]                                        = io.circe.generic.semiauto
        .deriveEncoder[LucumaTargetPreferencesSetInput]
        .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class LucumaTargetPreferencesStddevOrderBy(
      val fov: clue.data.Input[OrderBy] = clue.data.Ignore
    )
    object LucumaTargetPreferencesStddevOrderBy {
      implicit val fov
        : monocle.Lens[LucumaTargetPreferencesStddevOrderBy, clue.data.Input[OrderBy]] =
        monocle.macros.GenLens[LucumaTargetPreferencesStddevOrderBy](_.fov)
      implicit val eqLucumaTargetPreferencesStddevOrderBy
        : cats.Eq[LucumaTargetPreferencesStddevOrderBy]                                = cats.Eq.fromUniversalEquals
      implicit val showLucumaTargetPreferencesStddevOrderBy
        : cats.Show[LucumaTargetPreferencesStddevOrderBy]                              = cats.Show.fromToString
      implicit val jsonEncoderLucumaTargetPreferencesStddevOrderBy
        : io.circe.Encoder[LucumaTargetPreferencesStddevOrderBy]                       = io.circe.generic.semiauto
        .deriveEncoder[LucumaTargetPreferencesStddevOrderBy]
        .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class LucumaTargetPreferencesStddevPopOrderBy(
      val fov: clue.data.Input[OrderBy] = clue.data.Ignore
    )
    object LucumaTargetPreferencesStddevPopOrderBy {
      implicit val fov
        : monocle.Lens[LucumaTargetPreferencesStddevPopOrderBy, clue.data.Input[OrderBy]] =
        monocle.macros.GenLens[LucumaTargetPreferencesStddevPopOrderBy](_.fov)
      implicit val eqLucumaTargetPreferencesStddevPopOrderBy
        : cats.Eq[LucumaTargetPreferencesStddevPopOrderBy]                                = cats.Eq.fromUniversalEquals
      implicit val showLucumaTargetPreferencesStddevPopOrderBy
        : cats.Show[LucumaTargetPreferencesStddevPopOrderBy]                              = cats.Show.fromToString
      implicit val jsonEncoderLucumaTargetPreferencesStddevPopOrderBy
        : io.circe.Encoder[LucumaTargetPreferencesStddevPopOrderBy]                       = io.circe.generic.semiauto
        .deriveEncoder[LucumaTargetPreferencesStddevPopOrderBy]
        .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class LucumaTargetPreferencesStddevSampOrderBy(
      val fov: clue.data.Input[OrderBy] = clue.data.Ignore
    )
    object LucumaTargetPreferencesStddevSampOrderBy {
      implicit val fov
        : monocle.Lens[LucumaTargetPreferencesStddevSampOrderBy, clue.data.Input[OrderBy]] =
        monocle.macros.GenLens[LucumaTargetPreferencesStddevSampOrderBy](_.fov)
      implicit val eqLucumaTargetPreferencesStddevSampOrderBy
        : cats.Eq[LucumaTargetPreferencesStddevSampOrderBy]                                = cats.Eq.fromUniversalEquals
      implicit val showLucumaTargetPreferencesStddevSampOrderBy
        : cats.Show[LucumaTargetPreferencesStddevSampOrderBy]                              = cats.Show.fromToString
      implicit val jsonEncoderLucumaTargetPreferencesStddevSampOrderBy
        : io.circe.Encoder[LucumaTargetPreferencesStddevSampOrderBy]                       = io.circe.generic.semiauto
        .deriveEncoder[LucumaTargetPreferencesStddevSampOrderBy]
        .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class LucumaTargetPreferencesSumOrderBy(
      val fov: clue.data.Input[OrderBy] = clue.data.Ignore
    )
    object LucumaTargetPreferencesSumOrderBy {
      implicit val fov: monocle.Lens[LucumaTargetPreferencesSumOrderBy, clue.data.Input[OrderBy]]  =
        monocle.macros.GenLens[LucumaTargetPreferencesSumOrderBy](_.fov)
      implicit val eqLucumaTargetPreferencesSumOrderBy: cats.Eq[LucumaTargetPreferencesSumOrderBy] =
        cats.Eq.fromUniversalEquals
      implicit val showLucumaTargetPreferencesSumOrderBy
        : cats.Show[LucumaTargetPreferencesSumOrderBy]                                             = cats.Show.fromToString
      implicit val jsonEncoderLucumaTargetPreferencesSumOrderBy
        : io.circe.Encoder[LucumaTargetPreferencesSumOrderBy]                                      = io.circe.generic.semiauto
        .deriveEncoder[LucumaTargetPreferencesSumOrderBy]
        .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class LucumaTargetPreferencesVarPopOrderBy(
      val fov: clue.data.Input[OrderBy] = clue.data.Ignore
    )
    object LucumaTargetPreferencesVarPopOrderBy {
      implicit val fov
        : monocle.Lens[LucumaTargetPreferencesVarPopOrderBy, clue.data.Input[OrderBy]] =
        monocle.macros.GenLens[LucumaTargetPreferencesVarPopOrderBy](_.fov)
      implicit val eqLucumaTargetPreferencesVarPopOrderBy
        : cats.Eq[LucumaTargetPreferencesVarPopOrderBy]                                = cats.Eq.fromUniversalEquals
      implicit val showLucumaTargetPreferencesVarPopOrderBy
        : cats.Show[LucumaTargetPreferencesVarPopOrderBy]                              = cats.Show.fromToString
      implicit val jsonEncoderLucumaTargetPreferencesVarPopOrderBy
        : io.circe.Encoder[LucumaTargetPreferencesVarPopOrderBy]                       = io.circe.generic.semiauto
        .deriveEncoder[LucumaTargetPreferencesVarPopOrderBy]
        .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class LucumaTargetPreferencesVarSampOrderBy(
      val fov: clue.data.Input[OrderBy] = clue.data.Ignore
    )
    object LucumaTargetPreferencesVarSampOrderBy {
      implicit val fov
        : monocle.Lens[LucumaTargetPreferencesVarSampOrderBy, clue.data.Input[OrderBy]] =
        monocle.macros.GenLens[LucumaTargetPreferencesVarSampOrderBy](_.fov)
      implicit val eqLucumaTargetPreferencesVarSampOrderBy
        : cats.Eq[LucumaTargetPreferencesVarSampOrderBy]                                = cats.Eq.fromUniversalEquals
      implicit val showLucumaTargetPreferencesVarSampOrderBy
        : cats.Show[LucumaTargetPreferencesVarSampOrderBy]                              = cats.Show.fromToString
      implicit val jsonEncoderLucumaTargetPreferencesVarSampOrderBy
        : io.circe.Encoder[LucumaTargetPreferencesVarSampOrderBy]                       = io.circe.generic.semiauto
        .deriveEncoder[LucumaTargetPreferencesVarSampOrderBy]
        .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class LucumaTargetPreferencesVarianceOrderBy(
      val fov: clue.data.Input[OrderBy] = clue.data.Ignore
    )
    object LucumaTargetPreferencesVarianceOrderBy {
      implicit val fov
        : monocle.Lens[LucumaTargetPreferencesVarianceOrderBy, clue.data.Input[OrderBy]] =
        monocle.macros.GenLens[LucumaTargetPreferencesVarianceOrderBy](_.fov)
      implicit val eqLucumaTargetPreferencesVarianceOrderBy
        : cats.Eq[LucumaTargetPreferencesVarianceOrderBy]                                = cats.Eq.fromUniversalEquals
      implicit val showLucumaTargetPreferencesVarianceOrderBy
        : cats.Show[LucumaTargetPreferencesVarianceOrderBy]                              = cats.Show.fromToString
      implicit val jsonEncoderLucumaTargetPreferencesVarianceOrderBy
        : io.circe.Encoder[LucumaTargetPreferencesVarianceOrderBy]                       = io.circe.generic.semiauto
        .deriveEncoder[LucumaTargetPreferencesVarianceOrderBy]
        .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class LucumaTargetSetInput(val target_id: clue.data.Input[String] = clue.data.Ignore)
    object LucumaTargetSetInput {
      implicit val target_id: monocle.Lens[LucumaTargetSetInput, clue.data.Input[String]]  =
        monocle.macros.GenLens[LucumaTargetSetInput](_.target_id)
      implicit val eqLucumaTargetSetInput: cats.Eq[LucumaTargetSetInput]                   =
        cats.Eq.fromUniversalEquals
      implicit val showLucumaTargetSetInput: cats.Show[LucumaTargetSetInput]               =
        cats.Show.fromToString
      implicit val jsonEncoderLucumaTargetSetInput: io.circe.Encoder[LucumaTargetSetInput] =
        io.circe.generic.semiauto
          .deriveEncoder[LucumaTargetSetInput]
          .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class LucumaUserAggregateOrderBy(
      val count: clue.data.Input[OrderBy] = clue.data.Ignore,
      val max:   clue.data.Input[LucumaUserMaxOrderBy] = clue.data.Ignore,
      val min:   clue.data.Input[LucumaUserMinOrderBy] = clue.data.Ignore
    )
    object LucumaUserAggregateOrderBy {
      implicit val count: monocle.Lens[LucumaUserAggregateOrderBy, clue.data.Input[OrderBy]] =
        monocle.macros.GenLens[LucumaUserAggregateOrderBy](_.count)
      implicit val max
        : monocle.Lens[LucumaUserAggregateOrderBy, clue.data.Input[LucumaUserMaxOrderBy]]    =
        monocle.macros.GenLens[LucumaUserAggregateOrderBy](_.max)
      implicit val min
        : monocle.Lens[LucumaUserAggregateOrderBy, clue.data.Input[LucumaUserMinOrderBy]]    =
        monocle.macros.GenLens[LucumaUserAggregateOrderBy](_.min)
      implicit val eqLucumaUserAggregateOrderBy: cats.Eq[LucumaUserAggregateOrderBy]         =
        cats.Eq.fromUniversalEquals
      implicit val showLucumaUserAggregateOrderBy: cats.Show[LucumaUserAggregateOrderBy]     =
        cats.Show.fromToString
      implicit val jsonEncoderLucumaUserAggregateOrderBy
        : io.circe.Encoder[LucumaUserAggregateOrderBy]                                       = io.circe.generic.semiauto
        .deriveEncoder[LucumaUserAggregateOrderBy]
        .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class LucumaUserArrRelInsertInput(
      val data:        List[LucumaUserInsertInput],
      val on_conflict: clue.data.Input[LucumaUserOnConflict] = clue.data.Ignore
    )
    object LucumaUserArrRelInsertInput {
      implicit val data: monocle.Lens[LucumaUserArrRelInsertInput, List[LucumaUserInsertInput]] =
        monocle.macros.GenLens[LucumaUserArrRelInsertInput](_.data)
      implicit val on_conflict
        : monocle.Lens[LucumaUserArrRelInsertInput, clue.data.Input[LucumaUserOnConflict]]      =
        monocle.macros.GenLens[LucumaUserArrRelInsertInput](_.on_conflict)
      implicit val eqLucumaUserArrRelInsertInput: cats.Eq[LucumaUserArrRelInsertInput]          =
        cats.Eq.fromUniversalEquals
      implicit val showLucumaUserArrRelInsertInput: cats.Show[LucumaUserArrRelInsertInput]      =
        cats.Show.fromToString
      implicit val jsonEncoderLucumaUserArrRelInsertInput
        : io.circe.Encoder[LucumaUserArrRelInsertInput]                                         = io.circe.generic.semiauto
        .deriveEncoder[LucumaUserArrRelInsertInput]
        .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class LucumaUserBoolExp(
      val _and:    clue.data.Input[List[clue.data.Input[LucumaUserBoolExp]]] = clue.data.Ignore,
      val _not:    clue.data.Input[LucumaUserBoolExp] = clue.data.Ignore,
      val _or:     clue.data.Input[List[clue.data.Input[LucumaUserBoolExp]]] = clue.data.Ignore,
      val user_id: clue.data.Input[StringComparisonExp] = clue.data.Ignore
    )
    object LucumaUserBoolExp {
      implicit val _and: monocle.Lens[LucumaUserBoolExp, clue.data.Input[List[
        clue.data.Input[LucumaUserBoolExp]
      ]]]                                                                                         = monocle.macros.GenLens[LucumaUserBoolExp](_._and)
      implicit val _not: monocle.Lens[LucumaUserBoolExp, clue.data.Input[LucumaUserBoolExp]]      =
        monocle.macros.GenLens[LucumaUserBoolExp](_._not)
      implicit val _or: monocle.Lens[LucumaUserBoolExp, clue.data.Input[List[
        clue.data.Input[LucumaUserBoolExp]
      ]]]                                                                                         = monocle.macros.GenLens[LucumaUserBoolExp](_._or)
      implicit val user_id: monocle.Lens[LucumaUserBoolExp, clue.data.Input[StringComparisonExp]] =
        monocle.macros.GenLens[LucumaUserBoolExp](_.user_id)
      implicit val eqLucumaUserBoolExp: cats.Eq[LucumaUserBoolExp]                                = cats.Eq.fromUniversalEquals
      implicit val showLucumaUserBoolExp: cats.Show[LucumaUserBoolExp]                            = cats.Show.fromToString
      implicit val jsonEncoderLucumaUserBoolExp: io.circe.Encoder[LucumaUserBoolExp]              =
        io.circe.generic.semiauto
          .deriveEncoder[LucumaUserBoolExp]
          .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class LucumaUserInsertInput(val user_id: clue.data.Input[String] = clue.data.Ignore)
    object LucumaUserInsertInput {
      implicit val user_id: monocle.Lens[LucumaUserInsertInput, clue.data.Input[String]]     =
        monocle.macros.GenLens[LucumaUserInsertInput](_.user_id)
      implicit val eqLucumaUserInsertInput: cats.Eq[LucumaUserInsertInput]                   =
        cats.Eq.fromUniversalEquals
      implicit val showLucumaUserInsertInput: cats.Show[LucumaUserInsertInput]               =
        cats.Show.fromToString
      implicit val jsonEncoderLucumaUserInsertInput: io.circe.Encoder[LucumaUserInsertInput] =
        io.circe.generic.semiauto
          .deriveEncoder[LucumaUserInsertInput]
          .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class LucumaUserMaxOrderBy(val user_id: clue.data.Input[OrderBy] = clue.data.Ignore)
    object LucumaUserMaxOrderBy {
      implicit val user_id: monocle.Lens[LucumaUserMaxOrderBy, clue.data.Input[OrderBy]]   =
        monocle.macros.GenLens[LucumaUserMaxOrderBy](_.user_id)
      implicit val eqLucumaUserMaxOrderBy: cats.Eq[LucumaUserMaxOrderBy]                   =
        cats.Eq.fromUniversalEquals
      implicit val showLucumaUserMaxOrderBy: cats.Show[LucumaUserMaxOrderBy]               =
        cats.Show.fromToString
      implicit val jsonEncoderLucumaUserMaxOrderBy: io.circe.Encoder[LucumaUserMaxOrderBy] =
        io.circe.generic.semiauto
          .deriveEncoder[LucumaUserMaxOrderBy]
          .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class LucumaUserMinOrderBy(val user_id: clue.data.Input[OrderBy] = clue.data.Ignore)
    object LucumaUserMinOrderBy {
      implicit val user_id: monocle.Lens[LucumaUserMinOrderBy, clue.data.Input[OrderBy]]   =
        monocle.macros.GenLens[LucumaUserMinOrderBy](_.user_id)
      implicit val eqLucumaUserMinOrderBy: cats.Eq[LucumaUserMinOrderBy]                   =
        cats.Eq.fromUniversalEquals
      implicit val showLucumaUserMinOrderBy: cats.Show[LucumaUserMinOrderBy]               =
        cats.Show.fromToString
      implicit val jsonEncoderLucumaUserMinOrderBy: io.circe.Encoder[LucumaUserMinOrderBy] =
        io.circe.generic.semiauto
          .deriveEncoder[LucumaUserMinOrderBy]
          .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class LucumaUserObjRelInsertInput(
      val data:        LucumaUserInsertInput,
      val on_conflict: clue.data.Input[LucumaUserOnConflict] = clue.data.Ignore
    )
    object LucumaUserObjRelInsertInput {
      implicit val data: monocle.Lens[LucumaUserObjRelInsertInput, LucumaUserInsertInput]  =
        monocle.macros.GenLens[LucumaUserObjRelInsertInput](_.data)
      implicit val on_conflict
        : monocle.Lens[LucumaUserObjRelInsertInput, clue.data.Input[LucumaUserOnConflict]] =
        monocle.macros.GenLens[LucumaUserObjRelInsertInput](_.on_conflict)
      implicit val eqLucumaUserObjRelInsertInput: cats.Eq[LucumaUserObjRelInsertInput]     =
        cats.Eq.fromUniversalEquals
      implicit val showLucumaUserObjRelInsertInput: cats.Show[LucumaUserObjRelInsertInput] =
        cats.Show.fromToString
      implicit val jsonEncoderLucumaUserObjRelInsertInput
        : io.circe.Encoder[LucumaUserObjRelInsertInput]                                    = io.circe.generic.semiauto
        .deriveEncoder[LucumaUserObjRelInsertInput]
        .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class LucumaUserOnConflict(
      val constraint:     LucumaUserConstraint,
      val update_columns: List[LucumaUserUpdateColumn],
      val where:          clue.data.Input[LucumaUserBoolExp] = clue.data.Ignore
    )
    object LucumaUserOnConflict {
      implicit val constraint: monocle.Lens[LucumaUserOnConflict, LucumaUserConstraint]          =
        monocle.macros.GenLens[LucumaUserOnConflict](_.constraint)
      implicit val update_columns
        : monocle.Lens[LucumaUserOnConflict, List[LucumaUserUpdateColumn]]                       =
        monocle.macros.GenLens[LucumaUserOnConflict](_.update_columns)
      implicit val where: monocle.Lens[LucumaUserOnConflict, clue.data.Input[LucumaUserBoolExp]] =
        monocle.macros.GenLens[LucumaUserOnConflict](_.where)
      implicit val eqLucumaUserOnConflict: cats.Eq[LucumaUserOnConflict]                         =
        cats.Eq.fromUniversalEquals
      implicit val showLucumaUserOnConflict: cats.Show[LucumaUserOnConflict]                     =
        cats.Show.fromToString
      implicit val jsonEncoderLucumaUserOnConflict: io.circe.Encoder[LucumaUserOnConflict]       =
        io.circe.generic.semiauto
          .deriveEncoder[LucumaUserOnConflict]
          .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class LucumaUserOrderBy(val user_id: clue.data.Input[OrderBy] = clue.data.Ignore)
    object LucumaUserOrderBy {
      implicit val user_id: monocle.Lens[LucumaUserOrderBy, clue.data.Input[OrderBy]] =
        monocle.macros.GenLens[LucumaUserOrderBy](_.user_id)
      implicit val eqLucumaUserOrderBy: cats.Eq[LucumaUserOrderBy]                    = cats.Eq.fromUniversalEquals
      implicit val showLucumaUserOrderBy: cats.Show[LucumaUserOrderBy]                = cats.Show.fromToString
      implicit val jsonEncoderLucumaUserOrderBy: io.circe.Encoder[LucumaUserOrderBy]  =
        io.circe.generic.semiauto
          .deriveEncoder[LucumaUserOrderBy]
          .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class LucumaUserPkColumnsInput(val user_id: String)
    object LucumaUserPkColumnsInput {
      implicit val user_id: monocle.Lens[LucumaUserPkColumnsInput, String]                         =
        monocle.macros.GenLens[LucumaUserPkColumnsInput](_.user_id)
      implicit val eqLucumaUserPkColumnsInput: cats.Eq[LucumaUserPkColumnsInput]                   =
        cats.Eq.fromUniversalEquals
      implicit val showLucumaUserPkColumnsInput: cats.Show[LucumaUserPkColumnsInput]               =
        cats.Show.fromToString
      implicit val jsonEncoderLucumaUserPkColumnsInput: io.circe.Encoder[LucumaUserPkColumnsInput] =
        io.circe.generic.semiauto
          .deriveEncoder[LucumaUserPkColumnsInput]
          .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class LucumaUserSetInput(val user_id: clue.data.Input[String] = clue.data.Ignore)
    object LucumaUserSetInput {
      implicit val user_id: monocle.Lens[LucumaUserSetInput, clue.data.Input[String]]  =
        monocle.macros.GenLens[LucumaUserSetInput](_.user_id)
      implicit val eqLucumaUserSetInput: cats.Eq[LucumaUserSetInput]                   = cats.Eq.fromUniversalEquals
      implicit val showLucumaUserSetInput: cats.Show[LucumaUserSetInput]               = cats.Show.fromToString
      implicit val jsonEncoderLucumaUserSetInput: io.circe.Encoder[LucumaUserSetInput] =
        io.circe.generic.semiauto
          .deriveEncoder[LucumaUserSetInput]
          .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class ResizableAreaComparisonExp(
      val _eq:      clue.data.Input[ResizableArea] = clue.data.Ignore,
      val _gt:      clue.data.Input[ResizableArea] = clue.data.Ignore,
      val _gte:     clue.data.Input[ResizableArea] = clue.data.Ignore,
      val _in:      clue.data.Input[List[ResizableArea]] = clue.data.Ignore,
      val _is_null: clue.data.Input[Boolean] = clue.data.Ignore,
      val _lt:      clue.data.Input[ResizableArea] = clue.data.Ignore,
      val _lte:     clue.data.Input[ResizableArea] = clue.data.Ignore,
      val _neq:     clue.data.Input[ResizableArea] = clue.data.Ignore,
      val _nin:     clue.data.Input[List[ResizableArea]] = clue.data.Ignore
    )
    object ResizableAreaComparisonExp {
      implicit val _eq: monocle.Lens[ResizableAreaComparisonExp, clue.data.Input[ResizableArea]]  =
        monocle.macros.GenLens[ResizableAreaComparisonExp](_._eq)
      implicit val _gt: monocle.Lens[ResizableAreaComparisonExp, clue.data.Input[ResizableArea]]  =
        monocle.macros.GenLens[ResizableAreaComparisonExp](_._gt)
      implicit val _gte: monocle.Lens[ResizableAreaComparisonExp, clue.data.Input[ResizableArea]] =
        monocle.macros.GenLens[ResizableAreaComparisonExp](_._gte)
      implicit val _in
        : monocle.Lens[ResizableAreaComparisonExp, clue.data.Input[List[ResizableArea]]]          =
        monocle.macros.GenLens[ResizableAreaComparisonExp](_._in)
      implicit val _is_null: monocle.Lens[ResizableAreaComparisonExp, clue.data.Input[Boolean]]   =
        monocle.macros.GenLens[ResizableAreaComparisonExp](_._is_null)
      implicit val _lt: monocle.Lens[ResizableAreaComparisonExp, clue.data.Input[ResizableArea]]  =
        monocle.macros.GenLens[ResizableAreaComparisonExp](_._lt)
      implicit val _lte: monocle.Lens[ResizableAreaComparisonExp, clue.data.Input[ResizableArea]] =
        monocle.macros.GenLens[ResizableAreaComparisonExp](_._lte)
      implicit val _neq: monocle.Lens[ResizableAreaComparisonExp, clue.data.Input[ResizableArea]] =
        monocle.macros.GenLens[ResizableAreaComparisonExp](_._neq)
      implicit val _nin
        : monocle.Lens[ResizableAreaComparisonExp, clue.data.Input[List[ResizableArea]]]          =
        monocle.macros.GenLens[ResizableAreaComparisonExp](_._nin)
      implicit val eqResizableAreaComparisonExp: cats.Eq[ResizableAreaComparisonExp]              =
        cats.Eq.fromUniversalEquals
      implicit val showResizableAreaComparisonExp: cats.Show[ResizableAreaComparisonExp]          =
        cats.Show.fromToString
      implicit val jsonEncoderResizableAreaComparisonExp
        : io.circe.Encoder[ResizableAreaComparisonExp]                                            = io.circe.generic.semiauto
        .deriveEncoder[ResizableAreaComparisonExp]
        .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class StringComparisonExp(
      val _eq:       clue.data.Input[String] = clue.data.Ignore,
      val _gt:       clue.data.Input[String] = clue.data.Ignore,
      val _gte:      clue.data.Input[String] = clue.data.Ignore,
      val _ilike:    clue.data.Input[String] = clue.data.Ignore,
      val _in:       clue.data.Input[List[String]] = clue.data.Ignore,
      val _is_null:  clue.data.Input[Boolean] = clue.data.Ignore,
      val _like:     clue.data.Input[String] = clue.data.Ignore,
      val _lt:       clue.data.Input[String] = clue.data.Ignore,
      val _lte:      clue.data.Input[String] = clue.data.Ignore,
      val _neq:      clue.data.Input[String] = clue.data.Ignore,
      val _nilike:   clue.data.Input[String] = clue.data.Ignore,
      val _nin:      clue.data.Input[List[String]] = clue.data.Ignore,
      val _nlike:    clue.data.Input[String] = clue.data.Ignore,
      val _nsimilar: clue.data.Input[String] = clue.data.Ignore,
      val _similar:  clue.data.Input[String] = clue.data.Ignore
    )
    object StringComparisonExp {
      implicit val _eq: monocle.Lens[StringComparisonExp, clue.data.Input[String]]        =
        monocle.macros.GenLens[StringComparisonExp](_._eq)
      implicit val _gt: monocle.Lens[StringComparisonExp, clue.data.Input[String]]        =
        monocle.macros.GenLens[StringComparisonExp](_._gt)
      implicit val _gte: monocle.Lens[StringComparisonExp, clue.data.Input[String]]       =
        monocle.macros.GenLens[StringComparisonExp](_._gte)
      implicit val _ilike: monocle.Lens[StringComparisonExp, clue.data.Input[String]]     =
        monocle.macros.GenLens[StringComparisonExp](_._ilike)
      implicit val _in: monocle.Lens[StringComparisonExp, clue.data.Input[List[String]]]  =
        monocle.macros.GenLens[StringComparisonExp](_._in)
      implicit val _is_null: monocle.Lens[StringComparisonExp, clue.data.Input[Boolean]]  =
        monocle.macros.GenLens[StringComparisonExp](_._is_null)
      implicit val _like: monocle.Lens[StringComparisonExp, clue.data.Input[String]]      =
        monocle.macros.GenLens[StringComparisonExp](_._like)
      implicit val _lt: monocle.Lens[StringComparisonExp, clue.data.Input[String]]        =
        monocle.macros.GenLens[StringComparisonExp](_._lt)
      implicit val _lte: monocle.Lens[StringComparisonExp, clue.data.Input[String]]       =
        monocle.macros.GenLens[StringComparisonExp](_._lte)
      implicit val _neq: monocle.Lens[StringComparisonExp, clue.data.Input[String]]       =
        monocle.macros.GenLens[StringComparisonExp](_._neq)
      implicit val _nilike: monocle.Lens[StringComparisonExp, clue.data.Input[String]]    =
        monocle.macros.GenLens[StringComparisonExp](_._nilike)
      implicit val _nin: monocle.Lens[StringComparisonExp, clue.data.Input[List[String]]] =
        monocle.macros.GenLens[StringComparisonExp](_._nin)
      implicit val _nlike: monocle.Lens[StringComparisonExp, clue.data.Input[String]]     =
        monocle.macros.GenLens[StringComparisonExp](_._nlike)
      implicit val _nsimilar: monocle.Lens[StringComparisonExp, clue.data.Input[String]]  =
        monocle.macros.GenLens[StringComparisonExp](_._nsimilar)
      implicit val _similar: monocle.Lens[StringComparisonExp, clue.data.Input[String]]   =
        monocle.macros.GenLens[StringComparisonExp](_._similar)
      implicit val eqStringComparisonExp: cats.Eq[StringComparisonExp]                    = cats.Eq.fromUniversalEquals
      implicit val showStringComparisonExp: cats.Show[StringComparisonExp]                = cats.Show.fromToString
      implicit val jsonEncoderStringComparisonExp: io.circe.Encoder[StringComparisonExp]  =
        io.circe.generic.semiauto
          .deriveEncoder[StringComparisonExp]
          .mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
  }
  object Enums   {
    def ignoreUnusedImportEnums(): Unit = ()
    sealed trait ExploreResizableWidthConstraint
    object ExploreResizableWidthConstraint     {
      case object ExploreResizableWidthPkey extends ExploreResizableWidthConstraint()
      implicit val eqExploreResizableWidthConstraint: cats.Eq[ExploreResizableWidthConstraint]     =
        cats.Eq.fromUniversalEquals
      implicit val showExploreResizableWidthConstraint: cats.Show[ExploreResizableWidthConstraint] =
        cats.Show.fromToString
      implicit val jsonEncoderExploreResizableWidthConstraint
        : io.circe.Encoder[ExploreResizableWidthConstraint]                                        =
        io.circe.Encoder.encodeString.contramap[ExploreResizableWidthConstraint]({
          case ExploreResizableWidthPkey => "explore_resizable_width_pkey"
        })
      implicit val jsonDecoderExploreResizableWidthConstraint
        : io.circe.Decoder[ExploreResizableWidthConstraint]                                        =
        io.circe.Decoder.decodeString.emapTry(s =>
          scala.util.Try(s match {
            case "explore_resizable_width_pkey" => ExploreResizableWidthPkey
          })
        )
    }
    sealed trait ExploreResizableWidthSelectColumn
    object ExploreResizableWidthSelectColumn   {
      case object Section extends ExploreResizableWidthSelectColumn()
      case object UserId  extends ExploreResizableWidthSelectColumn()
      case object Width   extends ExploreResizableWidthSelectColumn()
      implicit val eqExploreResizableWidthSelectColumn: cats.Eq[ExploreResizableWidthSelectColumn] =
        cats.Eq.fromUniversalEquals
      implicit val showExploreResizableWidthSelectColumn
        : cats.Show[ExploreResizableWidthSelectColumn]                                             = cats.Show.fromToString
      implicit val jsonEncoderExploreResizableWidthSelectColumn
        : io.circe.Encoder[ExploreResizableWidthSelectColumn]                                      =
        io.circe.Encoder.encodeString.contramap[ExploreResizableWidthSelectColumn]({
          case Section => "section"
          case UserId  => "user_id"
          case Width   => "width"
        })
      implicit val jsonDecoderExploreResizableWidthSelectColumn
        : io.circe.Decoder[ExploreResizableWidthSelectColumn]                                      =
        io.circe.Decoder.decodeString.emapTry(s =>
          scala.util.Try(s match {
            case "section" => Section
            case "user_id" => UserId
            case "width"   => Width
          })
        )
    }
    sealed trait ExploreResizableWidthUpdateColumn
    object ExploreResizableWidthUpdateColumn   {
      case object Section extends ExploreResizableWidthUpdateColumn()
      case object UserId  extends ExploreResizableWidthUpdateColumn()
      case object Width   extends ExploreResizableWidthUpdateColumn()
      implicit val eqExploreResizableWidthUpdateColumn: cats.Eq[ExploreResizableWidthUpdateColumn] =
        cats.Eq.fromUniversalEquals
      implicit val showExploreResizableWidthUpdateColumn
        : cats.Show[ExploreResizableWidthUpdateColumn]                                             = cats.Show.fromToString
      implicit val jsonEncoderExploreResizableWidthUpdateColumn
        : io.circe.Encoder[ExploreResizableWidthUpdateColumn]                                      =
        io.circe.Encoder.encodeString.contramap[ExploreResizableWidthUpdateColumn]({
          case Section => "section"
          case UserId  => "user_id"
          case Width   => "width"
        })
      implicit val jsonDecoderExploreResizableWidthUpdateColumn
        : io.circe.Decoder[ExploreResizableWidthUpdateColumn]                                      =
        io.circe.Decoder.decodeString.emapTry(s =>
          scala.util.Try(s match {
            case "section" => Section
            case "user_id" => UserId
            case "width"   => Width
          })
        )
    }
    sealed trait GridLayoutPositionsConstraint
    object GridLayoutPositionsConstraint       {
      case object GridLayoutPositionsPkey extends GridLayoutPositionsConstraint()
      implicit val eqGridLayoutPositionsConstraint: cats.Eq[GridLayoutPositionsConstraint]     =
        cats.Eq.fromUniversalEquals
      implicit val showGridLayoutPositionsConstraint: cats.Show[GridLayoutPositionsConstraint] =
        cats.Show.fromToString
      implicit val jsonEncoderGridLayoutPositionsConstraint
        : io.circe.Encoder[GridLayoutPositionsConstraint]                                      =
        io.circe.Encoder.encodeString.contramap[GridLayoutPositionsConstraint]({
          case GridLayoutPositionsPkey => "grid_layout_positions_pkey"
        })
      implicit val jsonDecoderGridLayoutPositionsConstraint
        : io.circe.Decoder[GridLayoutPositionsConstraint]                                      =
        io.circe.Decoder.decodeString.emapTry(s =>
          scala.util.Try(s match {
            case "grid_layout_positions_pkey" => GridLayoutPositionsPkey
          })
        )
    }
    sealed trait GridLayoutPositionsSelectColumn
    object GridLayoutPositionsSelectColumn     {
      case object BreakpointName extends GridLayoutPositionsSelectColumn()
      case object Height         extends GridLayoutPositionsSelectColumn()
      case object Section        extends GridLayoutPositionsSelectColumn()
      case object Tile           extends GridLayoutPositionsSelectColumn()
      case object UserId         extends GridLayoutPositionsSelectColumn()
      case object Width          extends GridLayoutPositionsSelectColumn()
      case object X              extends GridLayoutPositionsSelectColumn()
      case object Y              extends GridLayoutPositionsSelectColumn()
      implicit val eqGridLayoutPositionsSelectColumn: cats.Eq[GridLayoutPositionsSelectColumn]     =
        cats.Eq.fromUniversalEquals
      implicit val showGridLayoutPositionsSelectColumn: cats.Show[GridLayoutPositionsSelectColumn] =
        cats.Show.fromToString
      implicit val jsonEncoderGridLayoutPositionsSelectColumn
        : io.circe.Encoder[GridLayoutPositionsSelectColumn]                                        =
        io.circe.Encoder.encodeString.contramap[GridLayoutPositionsSelectColumn]({
          case BreakpointName => "breakpoint_name"
          case Height         => "height"
          case Section        => "section"
          case Tile           => "tile"
          case UserId         => "user_id"
          case Width          => "width"
          case X              => "x"
          case Y              => "y"
        })
      implicit val jsonDecoderGridLayoutPositionsSelectColumn
        : io.circe.Decoder[GridLayoutPositionsSelectColumn]                                        =
        io.circe.Decoder.decodeString.emapTry(s =>
          scala.util.Try(s match {
            case "breakpoint_name" => BreakpointName
            case "height"          => Height
            case "section"         => Section
            case "tile"            => Tile
            case "user_id"         => UserId
            case "width"           => Width
            case "x"               => X
            case "y"               => Y
          })
        )
    }
    sealed trait GridLayoutPositionsUpdateColumn
    object GridLayoutPositionsUpdateColumn     {
      case object BreakpointName extends GridLayoutPositionsUpdateColumn()
      case object Height         extends GridLayoutPositionsUpdateColumn()
      case object Section        extends GridLayoutPositionsUpdateColumn()
      case object Tile           extends GridLayoutPositionsUpdateColumn()
      case object UserId         extends GridLayoutPositionsUpdateColumn()
      case object Width          extends GridLayoutPositionsUpdateColumn()
      case object X              extends GridLayoutPositionsUpdateColumn()
      case object Y              extends GridLayoutPositionsUpdateColumn()
      implicit val eqGridLayoutPositionsUpdateColumn: cats.Eq[GridLayoutPositionsUpdateColumn]     =
        cats.Eq.fromUniversalEquals
      implicit val showGridLayoutPositionsUpdateColumn: cats.Show[GridLayoutPositionsUpdateColumn] =
        cats.Show.fromToString
      implicit val jsonEncoderGridLayoutPositionsUpdateColumn
        : io.circe.Encoder[GridLayoutPositionsUpdateColumn]                                        =
        io.circe.Encoder.encodeString.contramap[GridLayoutPositionsUpdateColumn]({
          case BreakpointName => "breakpoint_name"
          case Height         => "height"
          case Section        => "section"
          case Tile           => "tile"
          case UserId         => "user_id"
          case Width          => "width"
          case X              => "x"
          case Y              => "y"
        })
      implicit val jsonDecoderGridLayoutPositionsUpdateColumn
        : io.circe.Decoder[GridLayoutPositionsUpdateColumn]                                        =
        io.circe.Decoder.decodeString.emapTry(s =>
          scala.util.Try(s match {
            case "breakpoint_name" => BreakpointName
            case "height"          => Height
            case "section"         => Section
            case "tile"            => Tile
            case "user_id"         => UserId
            case "width"           => Width
            case "x"               => X
            case "y"               => Y
          })
        )
    }
    sealed trait LucumaTargetConstraint
    object LucumaTargetConstraint              {
      case object LucumaTargetPkey extends LucumaTargetConstraint()
      implicit val eqLucumaTargetConstraint: cats.Eq[LucumaTargetConstraint]                   =
        cats.Eq.fromUniversalEquals
      implicit val showLucumaTargetConstraint: cats.Show[LucumaTargetConstraint]               =
        cats.Show.fromToString
      implicit val jsonEncoderLucumaTargetConstraint: io.circe.Encoder[LucumaTargetConstraint] =
        io.circe.Encoder.encodeString.contramap[LucumaTargetConstraint]({ case LucumaTargetPkey =>
          "lucuma_target_pkey"
        })
      implicit val jsonDecoderLucumaTargetConstraint: io.circe.Decoder[LucumaTargetConstraint] =
        io.circe.Decoder.decodeString.emapTry(s =>
          scala.util.Try(s match {
            case "lucuma_target_pkey" => LucumaTargetPkey
          })
        )
    }
    sealed trait LucumaTargetPreferencesConstraint
    object LucumaTargetPreferencesConstraint   {
      case object LucumaTargetPreferencesPkey extends LucumaTargetPreferencesConstraint()
      implicit val eqLucumaTargetPreferencesConstraint: cats.Eq[LucumaTargetPreferencesConstraint] =
        cats.Eq.fromUniversalEquals
      implicit val showLucumaTargetPreferencesConstraint
        : cats.Show[LucumaTargetPreferencesConstraint]                                             = cats.Show.fromToString
      implicit val jsonEncoderLucumaTargetPreferencesConstraint
        : io.circe.Encoder[LucumaTargetPreferencesConstraint]                                      =
        io.circe.Encoder.encodeString.contramap[LucumaTargetPreferencesConstraint]({
          case LucumaTargetPreferencesPkey => "lucuma_target_preferences_pkey"
        })
      implicit val jsonDecoderLucumaTargetPreferencesConstraint
        : io.circe.Decoder[LucumaTargetPreferencesConstraint]                                      =
        io.circe.Decoder.decodeString.emapTry(s =>
          scala.util.Try(s match {
            case "lucuma_target_preferences_pkey" => LucumaTargetPreferencesPkey
          })
        )
    }
    sealed trait LucumaTargetPreferencesSelectColumn
    object LucumaTargetPreferencesSelectColumn {
      case object Fov      extends LucumaTargetPreferencesSelectColumn()
      case object TargetId extends LucumaTargetPreferencesSelectColumn()
      case object UserId   extends LucumaTargetPreferencesSelectColumn()
      implicit val eqLucumaTargetPreferencesSelectColumn
        : cats.Eq[LucumaTargetPreferencesSelectColumn]          = cats.Eq.fromUniversalEquals
      implicit val showLucumaTargetPreferencesSelectColumn
        : cats.Show[LucumaTargetPreferencesSelectColumn]        = cats.Show.fromToString
      implicit val jsonEncoderLucumaTargetPreferencesSelectColumn
        : io.circe.Encoder[LucumaTargetPreferencesSelectColumn] =
        io.circe.Encoder.encodeString.contramap[LucumaTargetPreferencesSelectColumn]({
          case Fov      => "fov"
          case TargetId => "target_id"
          case UserId   => "user_id"
        })
      implicit val jsonDecoderLucumaTargetPreferencesSelectColumn
        : io.circe.Decoder[LucumaTargetPreferencesSelectColumn] =
        io.circe.Decoder.decodeString.emapTry(s =>
          scala.util.Try(s match {
            case "fov"       => Fov
            case "target_id" => TargetId
            case "user_id"   => UserId
          })
        )
    }
    sealed trait LucumaTargetPreferencesUpdateColumn
    object LucumaTargetPreferencesUpdateColumn {
      case object Fov      extends LucumaTargetPreferencesUpdateColumn()
      case object TargetId extends LucumaTargetPreferencesUpdateColumn()
      case object UserId   extends LucumaTargetPreferencesUpdateColumn()
      implicit val eqLucumaTargetPreferencesUpdateColumn
        : cats.Eq[LucumaTargetPreferencesUpdateColumn]          = cats.Eq.fromUniversalEquals
      implicit val showLucumaTargetPreferencesUpdateColumn
        : cats.Show[LucumaTargetPreferencesUpdateColumn]        = cats.Show.fromToString
      implicit val jsonEncoderLucumaTargetPreferencesUpdateColumn
        : io.circe.Encoder[LucumaTargetPreferencesUpdateColumn] =
        io.circe.Encoder.encodeString.contramap[LucumaTargetPreferencesUpdateColumn]({
          case Fov      => "fov"
          case TargetId => "target_id"
          case UserId   => "user_id"
        })
      implicit val jsonDecoderLucumaTargetPreferencesUpdateColumn
        : io.circe.Decoder[LucumaTargetPreferencesUpdateColumn] =
        io.circe.Decoder.decodeString.emapTry(s =>
          scala.util.Try(s match {
            case "fov"       => Fov
            case "target_id" => TargetId
            case "user_id"   => UserId
          })
        )
    }
    sealed trait LucumaTargetSelectColumn
    object LucumaTargetSelectColumn            {
      case object TargetId extends LucumaTargetSelectColumn()
      implicit val eqLucumaTargetSelectColumn: cats.Eq[LucumaTargetSelectColumn]                   =
        cats.Eq.fromUniversalEquals
      implicit val showLucumaTargetSelectColumn: cats.Show[LucumaTargetSelectColumn]               =
        cats.Show.fromToString
      implicit val jsonEncoderLucumaTargetSelectColumn: io.circe.Encoder[LucumaTargetSelectColumn] =
        io.circe.Encoder.encodeString.contramap[LucumaTargetSelectColumn]({ case TargetId =>
          "target_id"
        })
      implicit val jsonDecoderLucumaTargetSelectColumn: io.circe.Decoder[LucumaTargetSelectColumn] =
        io.circe.Decoder.decodeString.emapTry(s =>
          scala.util.Try(s match {
            case "target_id" => TargetId
          })
        )
    }
    sealed trait LucumaTargetUpdateColumn
    object LucumaTargetUpdateColumn            {
      case object TargetId extends LucumaTargetUpdateColumn()
      implicit val eqLucumaTargetUpdateColumn: cats.Eq[LucumaTargetUpdateColumn]                   =
        cats.Eq.fromUniversalEquals
      implicit val showLucumaTargetUpdateColumn: cats.Show[LucumaTargetUpdateColumn]               =
        cats.Show.fromToString
      implicit val jsonEncoderLucumaTargetUpdateColumn: io.circe.Encoder[LucumaTargetUpdateColumn] =
        io.circe.Encoder.encodeString.contramap[LucumaTargetUpdateColumn]({ case TargetId =>
          "target_id"
        })
      implicit val jsonDecoderLucumaTargetUpdateColumn: io.circe.Decoder[LucumaTargetUpdateColumn] =
        io.circe.Decoder.decodeString.emapTry(s =>
          scala.util.Try(s match {
            case "target_id" => TargetId
          })
        )
    }
    sealed trait LucumaUserConstraint
    object LucumaUserConstraint                {
      case object LucumaUserPkey extends LucumaUserConstraint()
      implicit val eqLucumaUserConstraint: cats.Eq[LucumaUserConstraint]                   =
        cats.Eq.fromUniversalEquals
      implicit val showLucumaUserConstraint: cats.Show[LucumaUserConstraint]               =
        cats.Show.fromToString
      implicit val jsonEncoderLucumaUserConstraint: io.circe.Encoder[LucumaUserConstraint] =
        io.circe.Encoder.encodeString.contramap[LucumaUserConstraint]({ case LucumaUserPkey =>
          "lucuma_user_pkey"
        })
      implicit val jsonDecoderLucumaUserConstraint: io.circe.Decoder[LucumaUserConstraint] =
        io.circe.Decoder.decodeString.emapTry(s =>
          scala.util.Try(s match {
            case "lucuma_user_pkey" => LucumaUserPkey
          })
        )
    }
    sealed trait LucumaUserSelectColumn
    object LucumaUserSelectColumn              {
      case object UserId extends LucumaUserSelectColumn()
      implicit val eqLucumaUserSelectColumn: cats.Eq[LucumaUserSelectColumn]                   =
        cats.Eq.fromUniversalEquals
      implicit val showLucumaUserSelectColumn: cats.Show[LucumaUserSelectColumn]               =
        cats.Show.fromToString
      implicit val jsonEncoderLucumaUserSelectColumn: io.circe.Encoder[LucumaUserSelectColumn] =
        io.circe.Encoder.encodeString.contramap[LucumaUserSelectColumn]({ case UserId =>
          "user_id"
        })
      implicit val jsonDecoderLucumaUserSelectColumn: io.circe.Decoder[LucumaUserSelectColumn] =
        io.circe.Decoder.decodeString.emapTry(s =>
          scala.util.Try(s match {
            case "user_id" => UserId
          })
        )
    }
    sealed trait LucumaUserUpdateColumn
    object LucumaUserUpdateColumn              {
      case object UserId extends LucumaUserUpdateColumn()
      implicit val eqLucumaUserUpdateColumn: cats.Eq[LucumaUserUpdateColumn]                   =
        cats.Eq.fromUniversalEquals
      implicit val showLucumaUserUpdateColumn: cats.Show[LucumaUserUpdateColumn]               =
        cats.Show.fromToString
      implicit val jsonEncoderLucumaUserUpdateColumn: io.circe.Encoder[LucumaUserUpdateColumn] =
        io.circe.Encoder.encodeString.contramap[LucumaUserUpdateColumn]({ case UserId =>
          "user_id"
        })
      implicit val jsonDecoderLucumaUserUpdateColumn: io.circe.Decoder[LucumaUserUpdateColumn] =
        io.circe.Decoder.decodeString.emapTry(s =>
          scala.util.Try(s match {
            case "user_id" => UserId
          })
        )
    }
    sealed trait OrderBy
    object OrderBy                             {
      case object Asc            extends OrderBy()
      case object AscNullsFirst  extends OrderBy()
      case object AscNullsLast   extends OrderBy()
      case object Desc           extends OrderBy()
      case object DescNullsFirst extends OrderBy()
      case object DescNullsLast  extends OrderBy()
      implicit val eqOrderBy: cats.Eq[OrderBy]                   = cats.Eq.fromUniversalEquals
      implicit val showOrderBy: cats.Show[OrderBy]               = cats.Show.fromToString
      implicit val jsonEncoderOrderBy: io.circe.Encoder[OrderBy] =
        io.circe.Encoder.encodeString.contramap[OrderBy]({
          case Asc            => "asc"
          case AscNullsFirst  => "asc_nulls_first"
          case AscNullsLast   => "asc_nulls_last"
          case Desc           => "desc"
          case DescNullsFirst => "desc_nulls_first"
          case DescNullsLast  => "desc_nulls_last"
        })
      implicit val jsonDecoderOrderBy: io.circe.Decoder[OrderBy] =
        io.circe.Decoder.decodeString.emapTry(s =>
          scala.util.Try(s match {
            case "asc"              => Asc
            case "asc_nulls_first"  => AscNullsFirst
            case "asc_nulls_last"   => AscNullsLast
            case "desc"             => Desc
            case "desc_nulls_first" => DescNullsFirst
            case "desc_nulls_last"  => DescNullsLast
          })
        )
    }
  }
}
/* END: Generated by clue. Will be replaced when regenerating. */
