// Copyright (c) 2016-2021 Association of Universities for Research in Astronomy, Inc. (AURA)
// For license information see LICENSE or https://opensource.org/licenses/BSD-3-Clause

package explore.common

import cats.data.NonEmptyList
import cats.effect.IO
import clue.GraphQLOperation
import clue.annotation.GraphQL
import clue.data.Input
import explore.AppCtx
import explore.components.graphql.LiveQueryRenderMod
import explore.data.KeyedIndexedList
import explore.implicits._
import explore.model.AirMassRange
import explore.model.ConstraintsSummary
import explore.model.ObsSummaryWithPointingAndConstraints
import explore.model.Pointing
import explore.model.reusability._
import explore.schemas.ObservationDB
import explore.schemas.ObservationDB.Types._
import io.circe.refined._
import japgolly.scalajs.react._
import japgolly.scalajs.react.vdom.html_<^._
import lucuma.core.model.ConstraintSet
import lucuma.core.model.Observation
import lucuma.ui.reusability._
import monocle.Getter
import monocle.macros.Lenses

object ConstraintSetObsQueries {
  type ConstraintSetList = KeyedIndexedList[ConstraintSet.Id, ConstraintsSummary]
  type ObsList           = KeyedIndexedList[Observation.Id, ObsSummaryWithPointingAndConstraints]

  def defaultCreateConstraintSet(
    cs: ConstraintsSummary
  ): CreateConstraintSetInput =
    CreateConstraintSetInput(
      constraintSetId = Input(cs.id),
      programId = "p-2",
      name = cs.name,
      imageQuality = cs.imageQuality,
      cloudExtinction = cs.cloudExtinction,
      skyBackground = cs.skyBackground,
      waterVapor = cs.waterVapor,
      elevationRange = CreateElevationRangeInput(airmassRange =
        clue.data.Input(
          CreateAirmassRangeInput(min = AirMassRange.DefaultMin.value,
                                  max = AirMassRange.DefaultMax.value
          )
        )
      )
    )

  @Lenses
  case class ConstraintSetsWithObs(constraintSets: ConstraintSetList, obs: ObsList)

  @GraphQL
  trait ConstraintSetsObsQueryGQL extends GraphQLOperation[ObservationDB] {
    val document = """
      query {
        constraintSets(programId: "p-2", first: 2147483647) {
          nodes {
            id
            name
            imageQuality
            cloudExtinction
            skyBackground
            waterVapor
          }
        }

        observations(programId: "p-2", first: 2147483647) {
          nodes {
            id
            observationTarget {
              type: __typename
              ... on Target {
                targetId: id
                targetName: name
              }
              ... on Asterism {
                asterismId: id
                asterismName: name
              }
            }
            constraintSet {
              id
              name
              imageQuality
              cloudExtinction
              skyBackground
              waterVapor
            }
          }
        }
      }
    """

    object Data {
      object ConstraintSets {
        type Nodes = ConstraintsSummary
      }

      object Observations {
        object Nodes {
          type ConstraintSet = ConstraintsSummary
        }
      }
    }
  }

  /* BEGIN: Generated by clue. DO NOT remove or edit the following code or this comment. */
  // format: off
  object ConstraintSetsObsQuery extends GraphQLOperation[ObservationDB] {
    import ObservationDB.Scalars._
    ignoreUnusedImportScalars()
    import ObservationDB.Enums._
    ignoreUnusedImportEnums()
    import ObservationDB.Types._
    ignoreUnusedImportTypes()
    val document = """
        query {
          constraintSets(programId: "p-2", first: 2147483647) {
            nodes {
              id
              name
              imageQuality
              cloudExtinction
              skyBackground
              waterVapor
            }
          }
  
          observations(programId: "p-2", first: 2147483647) {
            nodes {
              id
              observationTarget {
                type: __typename
                ... on Target {
                  targetId: id
                  targetName: name
                }
                ... on Asterism {
                  asterismId: id
                  asterismName: name
                }
              }
              constraintSet {
                id
                name
                imageQuality
                cloudExtinction
                skyBackground
                waterVapor
              }
            }
          }
        }
      """
    object Data {
      object ConstraintSets {
        type Nodes = ConstraintsSummary
        implicit val nodes: monocle.Lens[Data.ConstraintSets, List[Data.ConstraintSets.Nodes]] = monocle.macros.GenLens[Data.ConstraintSets](_.nodes)
        implicit val eqConstraintSets: cats.Eq[Data.ConstraintSets] = cats.Eq.fromUniversalEquals
        implicit val showConstraintSets: cats.Show[Data.ConstraintSets] = cats.Show.fromToString
        implicit val reuseConstraintSets: japgolly.scalajs.react.Reusability[Data.ConstraintSets] = {
          import japgolly.scalajs.react.Reusability
          japgolly.scalajs.react.Reusability.derive
        }
        implicit val jsonDecoderConstraintSets: io.circe.Decoder[Data.ConstraintSets] = io.circe.generic.semiauto.deriveDecoder[Data.ConstraintSets]
      }
      object Observations {
        object Nodes {
          type ConstraintSet = ConstraintsSummary
          sealed trait ObservationTarget
          object ObservationTarget {
            case class Target(val targetId: TargetId, val targetName: NonEmptyString) extends ObservationTarget()
            object Target {
              implicit val targetId: monocle.Lens[Data.Observations.Nodes.ObservationTarget.Target, TargetId] = monocle.macros.GenLens[Data.Observations.Nodes.ObservationTarget.Target](_.targetId)
              implicit val targetName: monocle.Lens[Data.Observations.Nodes.ObservationTarget.Target, NonEmptyString] = monocle.macros.GenLens[Data.Observations.Nodes.ObservationTarget.Target](_.targetName)
              implicit val eqTarget: cats.Eq[Data.Observations.Nodes.ObservationTarget.Target] = cats.Eq.fromUniversalEquals
              implicit val showTarget: cats.Show[Data.Observations.Nodes.ObservationTarget.Target] = cats.Show.fromToString
              implicit val reuseTarget: japgolly.scalajs.react.Reusability[Data.Observations.Nodes.ObservationTarget.Target] = {
                import japgolly.scalajs.react.Reusability
                japgolly.scalajs.react.Reusability.derive
              }
              implicit val jsonDecoderTarget: io.circe.Decoder[Data.Observations.Nodes.ObservationTarget.Target] = io.circe.generic.semiauto.deriveDecoder[Data.Observations.Nodes.ObservationTarget.Target]
            }
            case class Asterism(val asterismId: AsterismId, val asterismName: Option[NonEmptyString] = None) extends ObservationTarget()
            object Asterism {
              implicit val asterismId: monocle.Lens[Data.Observations.Nodes.ObservationTarget.Asterism, AsterismId] = monocle.macros.GenLens[Data.Observations.Nodes.ObservationTarget.Asterism](_.asterismId)
              implicit val asterismName: monocle.Lens[Data.Observations.Nodes.ObservationTarget.Asterism, Option[NonEmptyString]] = monocle.macros.GenLens[Data.Observations.Nodes.ObservationTarget.Asterism](_.asterismName)
              implicit val eqAsterism: cats.Eq[Data.Observations.Nodes.ObservationTarget.Asterism] = cats.Eq.fromUniversalEquals
              implicit val showAsterism: cats.Show[Data.Observations.Nodes.ObservationTarget.Asterism] = cats.Show.fromToString
              implicit val reuseAsterism: japgolly.scalajs.react.Reusability[Data.Observations.Nodes.ObservationTarget.Asterism] = {
                import japgolly.scalajs.react.Reusability
                japgolly.scalajs.react.Reusability.derive
              }
              implicit val jsonDecoderAsterism: io.circe.Decoder[Data.Observations.Nodes.ObservationTarget.Asterism] = io.circe.generic.semiauto.deriveDecoder[Data.Observations.Nodes.ObservationTarget.Asterism]
            }
            implicit val eqObservationTarget: cats.Eq[Data.Observations.Nodes.ObservationTarget] = cats.Eq.fromUniversalEquals
            implicit val showObservationTarget: cats.Show[Data.Observations.Nodes.ObservationTarget] = cats.Show.fromToString
            implicit val reuseObservationTarget: japgolly.scalajs.react.Reusability[Data.Observations.Nodes.ObservationTarget] = {
              import japgolly.scalajs.react.Reusability
              japgolly.scalajs.react.Reusability.derive
            }
            implicit protected val jsonConfiguration: io.circe.generic.extras.Configuration = io.circe.generic.extras.Configuration.default.withDiscriminator("type")
            implicit val jsonDecoderObservationTarget: io.circe.Decoder[Data.Observations.Nodes.ObservationTarget] = io.circe.generic.extras.semiauto.deriveConfiguredDecoder[Data.Observations.Nodes.ObservationTarget]
          }
          implicit val id: monocle.Lens[Data.Observations.Nodes, ObservationId] = monocle.macros.GenLens[Data.Observations.Nodes](_.id)
          implicit val observationTarget: monocle.Lens[Data.Observations.Nodes, Option[Data.Observations.Nodes.ObservationTarget]] = monocle.macros.GenLens[Data.Observations.Nodes](_.observationTarget)
          implicit val constraintSet: monocle.Lens[Data.Observations.Nodes, Option[Data.Observations.Nodes.ConstraintSet]] = monocle.macros.GenLens[Data.Observations.Nodes](_.constraintSet)
          implicit val eqNodes: cats.Eq[Data.Observations.Nodes] = cats.Eq.fromUniversalEquals
          implicit val showNodes: cats.Show[Data.Observations.Nodes] = cats.Show.fromToString
          implicit val reuseNodes: japgolly.scalajs.react.Reusability[Data.Observations.Nodes] = {
            import japgolly.scalajs.react.Reusability
            japgolly.scalajs.react.Reusability.derive
          }
          implicit val jsonDecoderNodes: io.circe.Decoder[Data.Observations.Nodes] = io.circe.generic.semiauto.deriveDecoder[Data.Observations.Nodes]
        }
        case class Nodes(val id: ObservationId, val observationTarget: Option[Data.Observations.Nodes.ObservationTarget] = None, val constraintSet: Option[Data.Observations.Nodes.ConstraintSet] = None)
        implicit val nodes: monocle.Lens[Data.Observations, List[Data.Observations.Nodes]] = monocle.macros.GenLens[Data.Observations](_.nodes)
        implicit val eqObservations: cats.Eq[Data.Observations] = cats.Eq.fromUniversalEquals
        implicit val showObservations: cats.Show[Data.Observations] = cats.Show.fromToString
        implicit val reuseObservations: japgolly.scalajs.react.Reusability[Data.Observations] = {
          import japgolly.scalajs.react.Reusability
          japgolly.scalajs.react.Reusability.derive
        }
        implicit val jsonDecoderObservations: io.circe.Decoder[Data.Observations] = io.circe.generic.semiauto.deriveDecoder[Data.Observations]
      }
      case class ConstraintSets(val nodes: List[Data.ConstraintSets.Nodes])
      case class Observations(val nodes: List[Data.Observations.Nodes])
      implicit val constraintSets: monocle.Lens[Data, Data.ConstraintSets] = monocle.macros.GenLens[Data](_.constraintSets)
      implicit val observations: monocle.Lens[Data, Data.Observations] = monocle.macros.GenLens[Data](_.observations)
      implicit val eqData: cats.Eq[Data] = cats.Eq.fromUniversalEquals
      implicit val showData: cats.Show[Data] = cats.Show.fromToString
      implicit val reuseData: japgolly.scalajs.react.Reusability[Data] = {
        import japgolly.scalajs.react.Reusability
        japgolly.scalajs.react.Reusability.derive
      }
      implicit val jsonDecoderData: io.circe.Decoder[Data] = io.circe.generic.semiauto.deriveDecoder[Data]
    }
    case class Variables()
    object Variables {
      implicit val eqVariables: cats.Eq[Variables] = cats.Eq.fromUniversalEquals
      implicit val showVariables: cats.Show[Variables] = cats.Show.fromToString
      implicit val jsonEncoderVariables: io.circe.Encoder[Variables] = io.circe.generic.semiauto.deriveEncoder[Variables].mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class Data(val constraintSets: Data.ConstraintSets, val observations: Data.Observations)
    val varEncoder: io.circe.Encoder[Variables] = Variables.jsonEncoderVariables
    val dataDecoder: io.circe.Decoder[Data] = Data.jsonDecoderData
    def query[F[_]]()(implicit client: clue.TransactionalClient[F, ObservationDB]) = client.request(this)(Variables())
  }
  // format: on
  /* END: Generated by clue. Will be replaced when regenerating. */

  private def convertPointing(
    pointing: ConstraintSetsObsQuery.Data.Observations.Nodes.ObservationTarget
  ): Pointing =
    pointing match {
      case ConstraintSetsObsQuery.Data.Observations.Nodes.ObservationTarget.Target(id, name)   =>
        Pointing.PointingTarget(id, name)
      case ConstraintSetsObsQuery.Data.Observations.Nodes.ObservationTarget.Asterism(id, name) =>
        Pointing.PointingAsterism(id, name, Nil)
    }

  private val constraintSetsObsQueryConstraintSetsWithObsGetter
    : Getter[ConstraintSetsObsQuery.Data, ConstraintSetsWithObs] = data => {
    ConstraintSetsWithObs(
      KeyedIndexedList.fromList(data.constraintSets.nodes, ConstraintsSummary.id.get),
      KeyedIndexedList.fromList(
        data.observations.nodes.map(node =>
          ObsSummaryWithPointingAndConstraints(node.id,
                                               node.observationTarget.map(convertPointing),
                                               node.constraintSet
          )
        ),
        ObsSummaryWithPointingAndConstraints.id.get
      )
    )
  }

  implicit class ConstraintSetsObsQueryDataOps(val self: ConstraintSetsObsQuery.Data.type)
      extends AnyVal {
    def asConstraintSetsWithObs = constraintSetsObsQueryConstraintSetsWithObsGetter
  }

  @GraphQL
  trait ConstraintSetEditSubscriptionGQL extends GraphQLOperation[ObservationDB] {
    val document = """
      subscription {
        constraintSetEdit(programId: "p-2") {
          id
        }
      }
    """
  }

  /* BEGIN: Generated by clue. DO NOT remove or edit the following code or this comment. */
  // format: off
  object ConstraintSetEditSubscription extends GraphQLOperation[ObservationDB] {
    import ObservationDB.Scalars._
    ignoreUnusedImportScalars()
    import ObservationDB.Enums._
    ignoreUnusedImportEnums()
    import ObservationDB.Types._
    ignoreUnusedImportTypes()
    val document = """
        subscription {
          constraintSetEdit(programId: "p-2") {
            id
          }
        }
      """
    case class Variables()
    object Variables {
      implicit val eqVariables: cats.Eq[Variables] = cats.Eq.fromUniversalEquals
      implicit val showVariables: cats.Show[Variables] = cats.Show.fromToString
      implicit val jsonEncoderVariables: io.circe.Encoder[Variables] = io.circe.generic.semiauto.deriveEncoder[Variables].mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class Data(val constraintSetEdit: Data.ConstraintSetEdit)
    object Data {
      case class ConstraintSetEdit(val id: Long)
      object ConstraintSetEdit {
        implicit val id: monocle.Lens[Data.ConstraintSetEdit, Long] = monocle.macros.GenLens[Data.ConstraintSetEdit](_.id)
        implicit val eqConstraintSetEdit: cats.Eq[Data.ConstraintSetEdit] = cats.Eq.fromUniversalEquals
        implicit val showConstraintSetEdit: cats.Show[Data.ConstraintSetEdit] = cats.Show.fromToString
        implicit val reuseConstraintSetEdit: japgolly.scalajs.react.Reusability[Data.ConstraintSetEdit] = {
          import japgolly.scalajs.react.Reusability
          japgolly.scalajs.react.Reusability.derive
        }
        implicit val jsonDecoderConstraintSetEdit: io.circe.Decoder[Data.ConstraintSetEdit] = io.circe.generic.semiauto.deriveDecoder[Data.ConstraintSetEdit]
      }
      implicit val constraintSetEdit: monocle.Lens[Data, Data.ConstraintSetEdit] = monocle.macros.GenLens[Data](_.constraintSetEdit)
      implicit val eqData: cats.Eq[Data] = cats.Eq.fromUniversalEquals
      implicit val showData: cats.Show[Data] = cats.Show.fromToString
      implicit val reuseData: japgolly.scalajs.react.Reusability[Data] = {
        import japgolly.scalajs.react.Reusability
        japgolly.scalajs.react.Reusability.derive
      }
      implicit val jsonDecoderData: io.circe.Decoder[Data] = io.circe.generic.semiauto.deriveDecoder[Data]
    }
    val varEncoder: io.circe.Encoder[Variables] = Variables.jsonEncoderVariables
    val dataDecoder: io.circe.Decoder[Data] = Data.jsonDecoderData
    def subscribe[F[_]]()(implicit client: clue.StreamingClient[F, ObservationDB]) = client.subscribe(this)(Variables())
  }
  // format: on
  /* END: Generated by clue. Will be replaced when regenerating. */

  @GraphQL
  trait AddConstraintSetGQL extends GraphQLOperation[ObservationDB] {
    val document = """
      mutation($input: CreateConstraintSetInput!) {
        createConstraintSet(input: $input) {
          id
        }
      }
    """
  }

  /* BEGIN: Generated by clue. DO NOT remove or edit the following code or this comment. */
  // format: off
  object AddConstraintSet extends GraphQLOperation[ObservationDB] {
    import ObservationDB.Scalars._
    ignoreUnusedImportScalars()
    import ObservationDB.Enums._
    ignoreUnusedImportEnums()
    import ObservationDB.Types._
    ignoreUnusedImportTypes()
    val document = """
        mutation($input: CreateConstraintSetInput!) {
          createConstraintSet(input: $input) {
            id
          }
        }
      """
    case class Variables(val input: CreateConstraintSetInput)
    object Variables {
      implicit val input: monocle.Lens[Variables, CreateConstraintSetInput] = monocle.macros.GenLens[Variables](_.input)
      implicit val eqVariables: cats.Eq[Variables] = cats.Eq.fromUniversalEquals
      implicit val showVariables: cats.Show[Variables] = cats.Show.fromToString
      implicit val jsonEncoderVariables: io.circe.Encoder[Variables] = io.circe.generic.semiauto.deriveEncoder[Variables].mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class Data(val createConstraintSet: Option[Data.CreateConstraintSet] = None)
    object Data {
      case class CreateConstraintSet(val id: ConstraintSetId)
      object CreateConstraintSet {
        implicit val id: monocle.Lens[Data.CreateConstraintSet, ConstraintSetId] = monocle.macros.GenLens[Data.CreateConstraintSet](_.id)
        implicit val eqCreateConstraintSet: cats.Eq[Data.CreateConstraintSet] = cats.Eq.fromUniversalEquals
        implicit val showCreateConstraintSet: cats.Show[Data.CreateConstraintSet] = cats.Show.fromToString
        implicit val reuseCreateConstraintSet: japgolly.scalajs.react.Reusability[Data.CreateConstraintSet] = {
          import japgolly.scalajs.react.Reusability
          japgolly.scalajs.react.Reusability.derive
        }
        implicit val jsonDecoderCreateConstraintSet: io.circe.Decoder[Data.CreateConstraintSet] = io.circe.generic.semiauto.deriveDecoder[Data.CreateConstraintSet]
      }
      implicit val createConstraintSet: monocle.Lens[Data, Option[Data.CreateConstraintSet]] = monocle.macros.GenLens[Data](_.createConstraintSet)
      implicit val eqData: cats.Eq[Data] = cats.Eq.fromUniversalEquals
      implicit val showData: cats.Show[Data] = cats.Show.fromToString
      implicit val reuseData: japgolly.scalajs.react.Reusability[Data] = {
        import japgolly.scalajs.react.Reusability
        japgolly.scalajs.react.Reusability.derive
      }
      implicit val jsonDecoderData: io.circe.Decoder[Data] = io.circe.generic.semiauto.deriveDecoder[Data]
    }
    val varEncoder: io.circe.Encoder[Variables] = Variables.jsonEncoderVariables
    val dataDecoder: io.circe.Decoder[Data] = Data.jsonDecoderData
    def execute[F[_]](input: CreateConstraintSetInput)(implicit client: clue.TransactionalClient[F, ObservationDB]) = client.request(this)(Variables(input))
  }
  // format: on
  /* END: Generated by clue. Will be replaced when regenerating. */

  @GraphQL
  trait DeleteConstraintSetGQL extends GraphQLOperation[ObservationDB] {
    val document = """
      mutation($constraintSetId: ConstraintSetId!) {
        deleteConstraintSet(constraintSetId: $constraintSetId) {
          id
        }
      }
    """
  }

  /* BEGIN: Generated by clue. DO NOT remove or edit the following code or this comment. */
  // format: off
  object DeleteConstraintSet extends GraphQLOperation[ObservationDB] {
    import ObservationDB.Scalars._
    ignoreUnusedImportScalars()
    import ObservationDB.Enums._
    ignoreUnusedImportEnums()
    import ObservationDB.Types._
    ignoreUnusedImportTypes()
    val document = """
        mutation($constraintSetId: ConstraintSetId!) {
          deleteConstraintSet(constraintSetId: $constraintSetId) {
            id
          }
        }
      """
    case class Variables(val constraintSetId: ConstraintSetId)
    object Variables {
      implicit val constraintSetId: monocle.Lens[Variables, ConstraintSetId] = monocle.macros.GenLens[Variables](_.constraintSetId)
      implicit val eqVariables: cats.Eq[Variables] = cats.Eq.fromUniversalEquals
      implicit val showVariables: cats.Show[Variables] = cats.Show.fromToString
      implicit val jsonEncoderVariables: io.circe.Encoder[Variables] = io.circe.generic.semiauto.deriveEncoder[Variables].mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class Data(val deleteConstraintSet: Data.DeleteConstraintSet)
    object Data {
      case class DeleteConstraintSet(val id: ConstraintSetId)
      object DeleteConstraintSet {
        implicit val id: monocle.Lens[Data.DeleteConstraintSet, ConstraintSetId] = monocle.macros.GenLens[Data.DeleteConstraintSet](_.id)
        implicit val eqDeleteConstraintSet: cats.Eq[Data.DeleteConstraintSet] = cats.Eq.fromUniversalEquals
        implicit val showDeleteConstraintSet: cats.Show[Data.DeleteConstraintSet] = cats.Show.fromToString
        implicit val reuseDeleteConstraintSet: japgolly.scalajs.react.Reusability[Data.DeleteConstraintSet] = {
          import japgolly.scalajs.react.Reusability
          japgolly.scalajs.react.Reusability.derive
        }
        implicit val jsonDecoderDeleteConstraintSet: io.circe.Decoder[Data.DeleteConstraintSet] = io.circe.generic.semiauto.deriveDecoder[Data.DeleteConstraintSet]
      }
      implicit val deleteConstraintSet: monocle.Lens[Data, Data.DeleteConstraintSet] = monocle.macros.GenLens[Data](_.deleteConstraintSet)
      implicit val eqData: cats.Eq[Data] = cats.Eq.fromUniversalEquals
      implicit val showData: cats.Show[Data] = cats.Show.fromToString
      implicit val reuseData: japgolly.scalajs.react.Reusability[Data] = {
        import japgolly.scalajs.react.Reusability
        japgolly.scalajs.react.Reusability.derive
      }
      implicit val jsonDecoderData: io.circe.Decoder[Data] = io.circe.generic.semiauto.deriveDecoder[Data]
    }
    val varEncoder: io.circe.Encoder[Variables] = Variables.jsonEncoderVariables
    val dataDecoder: io.circe.Decoder[Data] = Data.jsonDecoderData
    def execute[F[_]](constraintSetId: ConstraintSetId)(implicit client: clue.TransactionalClient[F, ObservationDB]) = client.request(this)(Variables(constraintSetId))
  }
  // format: on
  /* END: Generated by clue. Will be replaced when regenerating. */

  @GraphQL
  trait UndeleteConstraintSetGQL extends GraphQLOperation[ObservationDB] {
    val document = """
      mutation($constraintSetId: ConstraintSetId!) {
        undeleteContraintSet(constraintSetId: $constraintSetId) {
          id
        }
      }
    """
  }

  /* BEGIN: Generated by clue. DO NOT remove or edit the following code or this comment. */
  // format: off
  object UndeleteConstraintSet extends GraphQLOperation[ObservationDB] {
    import ObservationDB.Scalars._
    ignoreUnusedImportScalars()
    import ObservationDB.Enums._
    ignoreUnusedImportEnums()
    import ObservationDB.Types._
    ignoreUnusedImportTypes()
    val document = """
        mutation($constraintSetId: ConstraintSetId!) {
          undeleteContraintSet(constraintSetId: $constraintSetId) {
            id
          }
        }
      """
    case class Variables(val constraintSetId: ConstraintSetId)
    object Variables {
      implicit val constraintSetId: monocle.Lens[Variables, ConstraintSetId] = monocle.macros.GenLens[Variables](_.constraintSetId)
      implicit val eqVariables: cats.Eq[Variables] = cats.Eq.fromUniversalEquals
      implicit val showVariables: cats.Show[Variables] = cats.Show.fromToString
      implicit val jsonEncoderVariables: io.circe.Encoder[Variables] = io.circe.generic.semiauto.deriveEncoder[Variables].mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class Data(val undeleteContraintSet: Data.UndeleteContraintSet)
    object Data {
      case class UndeleteContraintSet(val id: ConstraintSetId)
      object UndeleteContraintSet {
        implicit val id: monocle.Lens[Data.UndeleteContraintSet, ConstraintSetId] = monocle.macros.GenLens[Data.UndeleteContraintSet](_.id)
        implicit val eqUndeleteContraintSet: cats.Eq[Data.UndeleteContraintSet] = cats.Eq.fromUniversalEquals
        implicit val showUndeleteContraintSet: cats.Show[Data.UndeleteContraintSet] = cats.Show.fromToString
        implicit val reuseUndeleteContraintSet: japgolly.scalajs.react.Reusability[Data.UndeleteContraintSet] = {
          import japgolly.scalajs.react.Reusability
          japgolly.scalajs.react.Reusability.derive
        }
        implicit val jsonDecoderUndeleteContraintSet: io.circe.Decoder[Data.UndeleteContraintSet] = io.circe.generic.semiauto.deriveDecoder[Data.UndeleteContraintSet]
      }
      implicit val undeleteContraintSet: monocle.Lens[Data, Data.UndeleteContraintSet] = monocle.macros.GenLens[Data](_.undeleteContraintSet)
      implicit val eqData: cats.Eq[Data] = cats.Eq.fromUniversalEquals
      implicit val showData: cats.Show[Data] = cats.Show.fromToString
      implicit val reuseData: japgolly.scalajs.react.Reusability[Data] = {
        import japgolly.scalajs.react.Reusability
        japgolly.scalajs.react.Reusability.derive
      }
      implicit val jsonDecoderData: io.circe.Decoder[Data] = io.circe.generic.semiauto.deriveDecoder[Data]
    }
    val varEncoder: io.circe.Encoder[Variables] = Variables.jsonEncoderVariables
    val dataDecoder: io.circe.Decoder[Data] = Data.jsonDecoderData
    def execute[F[_]](constraintSetId: ConstraintSetId)(implicit client: clue.TransactionalClient[F, ObservationDB]) = client.request(this)(Variables(constraintSetId))
  }
  // format: on
  /* END: Generated by clue. Will be replaced when regenerating. */

  @GraphQL
  trait AssignConstraintSetToObsGQL extends GraphQLOperation[ObservationDB] {
    val document: String = """
      mutation($constraintSetId: ConstraintSetId!, $obsId: ObservationId!) {
        updateObservationConstraintSet(
          input: { constraintSetId: $constraintSetId, observationIds: [$obsId] }
        ) {
          id
        }
      }
    """
  }

  /* BEGIN: Generated by clue. DO NOT remove or edit the following code or this comment. */
  // format: off
  object AssignConstraintSetToObs extends GraphQLOperation[ObservationDB] {
    import ObservationDB.Scalars._
    ignoreUnusedImportScalars()
    import ObservationDB.Enums._
    ignoreUnusedImportEnums()
    import ObservationDB.Types._
    ignoreUnusedImportTypes()
    val document: String = """
        mutation($constraintSetId: ConstraintSetId!, $obsId: ObservationId!) {
          updateObservationConstraintSet(
            input: { constraintSetId: $constraintSetId, observationIds: [$obsId] }
          ) {
            id
          }
        }
      """
    case class Variables(val constraintSetId: ConstraintSetId, val obsId: ObservationId)
    object Variables {
      implicit val constraintSetId: monocle.Lens[Variables, ConstraintSetId] = monocle.macros.GenLens[Variables](_.constraintSetId)
      implicit val obsId: monocle.Lens[Variables, ObservationId] = monocle.macros.GenLens[Variables](_.obsId)
      implicit val eqVariables: cats.Eq[Variables] = cats.Eq.fromUniversalEquals
      implicit val showVariables: cats.Show[Variables] = cats.Show.fromToString
      implicit val jsonEncoderVariables: io.circe.Encoder[Variables] = io.circe.generic.semiauto.deriveEncoder[Variables].mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class Data(val updateObservationConstraintSet: List[Data.UpdateObservationConstraintSet])
    object Data {
      case class UpdateObservationConstraintSet(val id: ObservationId)
      object UpdateObservationConstraintSet {
        implicit val id: monocle.Lens[Data.UpdateObservationConstraintSet, ObservationId] = monocle.macros.GenLens[Data.UpdateObservationConstraintSet](_.id)
        implicit val eqUpdateObservationConstraintSet: cats.Eq[Data.UpdateObservationConstraintSet] = cats.Eq.fromUniversalEquals
        implicit val showUpdateObservationConstraintSet: cats.Show[Data.UpdateObservationConstraintSet] = cats.Show.fromToString
        implicit val reuseUpdateObservationConstraintSet: japgolly.scalajs.react.Reusability[Data.UpdateObservationConstraintSet] = {
          import japgolly.scalajs.react.Reusability
          japgolly.scalajs.react.Reusability.derive
        }
        implicit val jsonDecoderUpdateObservationConstraintSet: io.circe.Decoder[Data.UpdateObservationConstraintSet] = io.circe.generic.semiauto.deriveDecoder[Data.UpdateObservationConstraintSet]
      }
      implicit val updateObservationConstraintSet: monocle.Lens[Data, List[Data.UpdateObservationConstraintSet]] = monocle.macros.GenLens[Data](_.updateObservationConstraintSet)
      implicit val eqData: cats.Eq[Data] = cats.Eq.fromUniversalEquals
      implicit val showData: cats.Show[Data] = cats.Show.fromToString
      implicit val reuseData: japgolly.scalajs.react.Reusability[Data] = {
        import japgolly.scalajs.react.Reusability
        japgolly.scalajs.react.Reusability.derive
      }
      implicit val jsonDecoderData: io.circe.Decoder[Data] = io.circe.generic.semiauto.deriveDecoder[Data]
    }
    val varEncoder: io.circe.Encoder[Variables] = Variables.jsonEncoderVariables
    val dataDecoder: io.circe.Decoder[Data] = Data.jsonDecoderData
    def execute[F[_]](constraintSetId: ConstraintSetId, obsId: ObservationId)(implicit client: clue.TransactionalClient[F, ObservationDB]) = client.request(this)(Variables(constraintSetId, obsId))
  }
  // format: on
  /* END: Generated by clue. Will be replaced when regenerating. */

  @GraphQL
  trait UnassignConstraintSetFromObsGQL extends GraphQLOperation[ObservationDB] {
    val document: String = """
      mutation($obsId: ObservationId!) {
        updateObservationConstraintSet(
          input: { observationIds: [$obsId], constraintSetId: null }
         ) {
          id
        }
      }
    """
  }

  /* BEGIN: Generated by clue. DO NOT remove or edit the following code or this comment. */
  // format: off
  object UnassignConstraintSetFromObs extends GraphQLOperation[ObservationDB] {
    import ObservationDB.Scalars._
    ignoreUnusedImportScalars()
    import ObservationDB.Enums._
    ignoreUnusedImportEnums()
    import ObservationDB.Types._
    ignoreUnusedImportTypes()
    val document: String = """
        mutation($obsId: ObservationId!) {
          updateObservationConstraintSet(
            input: { observationIds: [$obsId], constraintSetId: null }
           ) {
            id
          }
        }
      """
    case class Variables(val obsId: ObservationId)
    object Variables {
      implicit val obsId: monocle.Lens[Variables, ObservationId] = monocle.macros.GenLens[Variables](_.obsId)
      implicit val eqVariables: cats.Eq[Variables] = cats.Eq.fromUniversalEquals
      implicit val showVariables: cats.Show[Variables] = cats.Show.fromToString
      implicit val jsonEncoderVariables: io.circe.Encoder[Variables] = io.circe.generic.semiauto.deriveEncoder[Variables].mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class Data(val updateObservationConstraintSet: List[Data.UpdateObservationConstraintSet])
    object Data {
      case class UpdateObservationConstraintSet(val id: ObservationId)
      object UpdateObservationConstraintSet {
        implicit val id: monocle.Lens[Data.UpdateObservationConstraintSet, ObservationId] = monocle.macros.GenLens[Data.UpdateObservationConstraintSet](_.id)
        implicit val eqUpdateObservationConstraintSet: cats.Eq[Data.UpdateObservationConstraintSet] = cats.Eq.fromUniversalEquals
        implicit val showUpdateObservationConstraintSet: cats.Show[Data.UpdateObservationConstraintSet] = cats.Show.fromToString
        implicit val reuseUpdateObservationConstraintSet: japgolly.scalajs.react.Reusability[Data.UpdateObservationConstraintSet] = {
          import japgolly.scalajs.react.Reusability
          japgolly.scalajs.react.Reusability.derive
        }
        implicit val jsonDecoderUpdateObservationConstraintSet: io.circe.Decoder[Data.UpdateObservationConstraintSet] = io.circe.generic.semiauto.deriveDecoder[Data.UpdateObservationConstraintSet]
      }
      implicit val updateObservationConstraintSet: monocle.Lens[Data, List[Data.UpdateObservationConstraintSet]] = monocle.macros.GenLens[Data](_.updateObservationConstraintSet)
      implicit val eqData: cats.Eq[Data] = cats.Eq.fromUniversalEquals
      implicit val showData: cats.Show[Data] = cats.Show.fromToString
      implicit val reuseData: japgolly.scalajs.react.Reusability[Data] = {
        import japgolly.scalajs.react.Reusability
        japgolly.scalajs.react.Reusability.derive
      }
      implicit val jsonDecoderData: io.circe.Decoder[Data] = io.circe.generic.semiauto.deriveDecoder[Data]
    }
    val varEncoder: io.circe.Encoder[Variables] = Variables.jsonEncoderVariables
    val dataDecoder: io.circe.Decoder[Data] = Data.jsonDecoderData
    def execute[F[_]](obsId: ObservationId)(implicit client: clue.TransactionalClient[F, ObservationDB]) = client.request(this)(Variables(obsId))
  }
  // format: on
  /* END: Generated by clue. Will be replaced when regenerating. */

  implicit val constraintSetWithObsReusability: Reusability[ConstraintSetsWithObs] =
    Reusability.derive

  val ConstraintSetObsLiveQuery =
    ScalaFnComponent[View[ConstraintSetsWithObs] => VdomNode](render =>
      AppCtx.using { implicit appCtx =>
        LiveQueryRenderMod[ObservationDB, ConstraintSetsObsQuery.Data, ConstraintSetsWithObs](
          ConstraintSetsObsQuery.query(),
          ConstraintSetsObsQuery.Data.asConstraintSetsWithObs.get,
          NonEmptyList.of(
            ConstraintSetEditSubscription.subscribe[IO](),
            ObsQueries.ProgramObservationsEditSubscription.subscribe[IO]()
          )
        )(render)
      }
    )

}
