// Copyright (c) 2016-2021 Association of Universities for Research in Astronomy, Inc. (AURA)
// For license information see LICENSE or https://opensource.org/licenses/BSD-3-Clause

package explore.common

import cats.Endo
import cats.effect.IO
import cats.syntax.all._
import clue.GraphQLOperation
import clue.annotation.GraphQL
import clue.data.syntax._
import eu.timepit.refined.auto._
import explore.implicits._
import explore.model.decoders._
import explore.optics._
import explore.schemas.ObservationDB.Types._
import explore.schemas._
import explore.schemas.implicits._
import explore.undo.UndoableView
import explore.undo.Undoer
import io.circe.refined._
import lucuma.core.math.Coordinates
import lucuma.core.math.Declination
import lucuma.core.math.Epoch
import lucuma.core.math.Parallax
import lucuma.core.math.ProperMotion
import lucuma.core.math.RadialVelocity
import lucuma.core.math.RightAscension
import lucuma.core.math.units.CentimetersPerSecond
import lucuma.core.model.CatalogId
import lucuma.core.model.Magnitude
import lucuma.core.model.SiderealTracking
import lucuma.core.model.Target
import lucuma.ui.reusability._
import monocle.Lens

object TargetQueries {

  @GraphQL
  trait TargetEditQueryGQL extends GraphQLOperation[ObservationDB] {
    val document = """
      query($id: TargetId!) {
        target(targetId: $id) {
          id
          name
          tracking {
            ... on Sidereal {
              coordinates {
                ra {
                  microarcseconds
                }
                dec {
                  microarcseconds
                }
              }
              epoch
              properMotion {
                ra {
                  microarcsecondsPerYear
                }
              	dec {
                  microarcsecondsPerYear
                }
							}
              radialVelocity {
                centimetersPerSecond
              }
              parallax {
                microarcseconds
              }
            }
          }
          magnitudes {
            value
            band
            system
          }
        }
      }
      """

    object Data {
      object Target {
        type Tracking   = lucuma.core.model.SiderealTracking
        type Magnitudes = lucuma.core.model.Magnitude
      }
    }
  }

  /* BEGIN: Generated by clue. DO NOT remove or edit the following code or this comment. */
  // format: off
  object TargetEditQuery extends GraphQLOperation[ObservationDB] {
    import ObservationDB.Scalars._
    ignoreUnusedImportScalars()
    import ObservationDB.Enums._
    ignoreUnusedImportEnums()
    import ObservationDB.Types._
    ignoreUnusedImportTypes()
    val document = """
        query($id: TargetId!) {
          target(targetId: $id) {
            id
            name
            tracking {
              ... on Sidereal {
                coordinates {
                  ra {
                    microarcseconds
                  }
                  dec {
                    microarcseconds
                  }
                }
                epoch
                properMotion {
                  ra {
                    microarcsecondsPerYear
                  }
                	dec {
                    microarcsecondsPerYear
                  }
  							}
                radialVelocity {
                  centimetersPerSecond
                }
                parallax {
                  microarcseconds
                }
              }
            }
            magnitudes {
              value
              band
              system
            }
          }
        }
        """
    object Data {
      object Target {
        type Tracking = lucuma.core.model.SiderealTracking
        type Magnitudes = lucuma.core.model.Magnitude
        implicit val id: monocle.Lens[Data.Target, TargetId] = monocle.macros.GenLens[Data.Target](_.id)
        implicit val name: monocle.Lens[Data.Target, NonEmptyString] = monocle.macros.GenLens[Data.Target](_.name)
        implicit val tracking: monocle.Lens[Data.Target, Data.Target.Tracking] = monocle.macros.GenLens[Data.Target](_.tracking)
        implicit val magnitudes: monocle.Lens[Data.Target, List[Data.Target.Magnitudes]] = monocle.macros.GenLens[Data.Target](_.magnitudes)
        implicit val eqTarget: cats.Eq[Data.Target] = cats.Eq.fromUniversalEquals
        implicit val showTarget: cats.Show[Data.Target] = cats.Show.fromToString
        implicit val reuseTarget: japgolly.scalajs.react.Reusability[Data.Target] = {
          import japgolly.scalajs.react.Reusability
          japgolly.scalajs.react.Reusability.derive
        }
        implicit val jsonDecoderTarget: io.circe.Decoder[Data.Target] = io.circe.generic.semiauto.deriveDecoder[Data.Target]
      }
      case class Target(val id: TargetId, val name: NonEmptyString, val tracking: Data.Target.Tracking, val magnitudes: List[Data.Target.Magnitudes])
      implicit val target: monocle.Lens[Data, Option[Data.Target]] = monocle.macros.GenLens[Data](_.target)
      implicit val eqData: cats.Eq[Data] = cats.Eq.fromUniversalEquals
      implicit val showData: cats.Show[Data] = cats.Show.fromToString
      implicit val reuseData: japgolly.scalajs.react.Reusability[Data] = {
        import japgolly.scalajs.react.Reusability
        japgolly.scalajs.react.Reusability.derive
      }
      implicit val jsonDecoderData: io.circe.Decoder[Data] = io.circe.generic.semiauto.deriveDecoder[Data]
    }
    case class Variables(val id: TargetId)
    object Variables {
      implicit val id: monocle.Lens[Variables, TargetId] = monocle.macros.GenLens[Variables](_.id)
      implicit val eqVariables: cats.Eq[Variables] = cats.Eq.fromUniversalEquals
      implicit val showVariables: cats.Show[Variables] = cats.Show.fromToString
      implicit val jsonEncoderVariables: io.circe.Encoder[Variables] = io.circe.generic.semiauto.deriveEncoder[Variables].mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class Data(val target: Option[Data.Target] = None)
    val varEncoder: io.circe.Encoder[Variables] = Variables.jsonEncoderVariables
    val dataDecoder: io.circe.Decoder[Data] = Data.jsonDecoderData
    def query[F[_]](id: TargetId)(implicit client: clue.TransactionalClient[F, ObservationDB]) = client.request(this)(Variables(id))
  }
  // format: on
  /* END: Generated by clue. Will be replaced when regenerating. */

  type TargetResult = TargetEditQuery.Data.Target
  val TargetResult = TargetEditQuery.Data.Target

  /**
   * Lens for the base coordinates of TargetResult.Tracking
   */
  val baseCoordinates: Lens[TargetResult, Coordinates] =
    TargetResult.tracking ^|-> SiderealTracking.baseCoordinates

  val baseCoordinatesRa: Lens[TargetResult, RightAscension] =
    baseCoordinates ^|-> Coordinates.rightAscension

  val baseCoordinatesDec: Lens[TargetResult, Declination] =
    baseCoordinates ^|-> Coordinates.declination

  /**
   * Lens used to change name and coordinates of a target
   */
  val targetPropsL = disjointZip(TargetResult.name, TargetResult.tracking, TargetResult.magnitudes)

  val pmRALens: Lens[TargetResult, Option[ProperMotion.RA]] =
    TargetResult.tracking ^|-> SiderealTracking.properMotion ^|-> unsafePMRALensO

  val pmDecLens: Lens[TargetResult, Option[ProperMotion.Dec]] =
    TargetResult.tracking ^|-> SiderealTracking.properMotion ^|-> unsafePMDecLensO

  val epoch: Lens[TargetResult, Epoch] =
    TargetResult.tracking ^|-> SiderealTracking.epoch

  val pxLens: Lens[TargetResult, Option[Parallax]] =
    TargetResult.tracking ^|-> SiderealTracking.parallax

  val rvLens: Lens[TargetResult, Option[RadialVelocity]] =
    TargetResult.tracking ^|-> SiderealTracking.radialVelocity

  @GraphQL
  trait TargetEditSubscriptionGQL extends GraphQLOperation[ObservationDB] {
    val document = """
      subscription($id: TargetId!) {
        targetEdit(targetId: $id) {
          id
        }
      }
      """
  }

  /* BEGIN: Generated by clue. DO NOT remove or edit the following code or this comment. */
  // format: off
  object TargetEditSubscription extends GraphQLOperation[ObservationDB] {
    import ObservationDB.Scalars._
    ignoreUnusedImportScalars()
    import ObservationDB.Enums._
    ignoreUnusedImportEnums()
    import ObservationDB.Types._
    ignoreUnusedImportTypes()
    val document = """
        subscription($id: TargetId!) {
          targetEdit(targetId: $id) {
            id
          }
        }
        """
    case class Variables(val id: TargetId)
    object Variables {
      implicit val id: monocle.Lens[Variables, TargetId] = monocle.macros.GenLens[Variables](_.id)
      implicit val eqVariables: cats.Eq[Variables] = cats.Eq.fromUniversalEquals
      implicit val showVariables: cats.Show[Variables] = cats.Show.fromToString
      implicit val jsonEncoderVariables: io.circe.Encoder[Variables] = io.circe.generic.semiauto.deriveEncoder[Variables].mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class Data(val targetEdit: Data.TargetEdit)
    object Data {
      case class TargetEdit(val id: Long)
      object TargetEdit {
        implicit val id: monocle.Lens[Data.TargetEdit, Long] = monocle.macros.GenLens[Data.TargetEdit](_.id)
        implicit val eqTargetEdit: cats.Eq[Data.TargetEdit] = cats.Eq.fromUniversalEquals
        implicit val showTargetEdit: cats.Show[Data.TargetEdit] = cats.Show.fromToString
        implicit val reuseTargetEdit: japgolly.scalajs.react.Reusability[Data.TargetEdit] = {
          import japgolly.scalajs.react.Reusability
          japgolly.scalajs.react.Reusability.derive
        }
        implicit val jsonDecoderTargetEdit: io.circe.Decoder[Data.TargetEdit] = io.circe.generic.semiauto.deriveDecoder[Data.TargetEdit]
      }
      implicit val targetEdit: monocle.Lens[Data, Data.TargetEdit] = monocle.macros.GenLens[Data](_.targetEdit)
      implicit val eqData: cats.Eq[Data] = cats.Eq.fromUniversalEquals
      implicit val showData: cats.Show[Data] = cats.Show.fromToString
      implicit val reuseData: japgolly.scalajs.react.Reusability[Data] = {
        import japgolly.scalajs.react.Reusability
        japgolly.scalajs.react.Reusability.derive
      }
      implicit val jsonDecoderData: io.circe.Decoder[Data] = io.circe.generic.semiauto.deriveDecoder[Data]
    }
    val varEncoder: io.circe.Encoder[Variables] = Variables.jsonEncoderVariables
    val dataDecoder: io.circe.Decoder[Data] = Data.jsonDecoderData
    def subscribe[F[_]](id: TargetId)(implicit client: clue.StreamingClient[F, ObservationDB]) = client.subscribe(this)(Variables(id))
  }
  // format: on
  /* END: Generated by clue. Will be replaced when regenerating. */

  @GraphQL
  trait TargetMutationGQL extends GraphQLOperation[ObservationDB] {
    val document = """
      mutation($input: EditSiderealInput!) {
        updateSiderealTarget(input: $input) {
          id
        }
      }
    """
  }

  /* BEGIN: Generated by clue. DO NOT remove or edit the following code or this comment. */
  // format: off
  object TargetMutation extends GraphQLOperation[ObservationDB] {
    import ObservationDB.Scalars._
    ignoreUnusedImportScalars()
    import ObservationDB.Enums._
    ignoreUnusedImportEnums()
    import ObservationDB.Types._
    ignoreUnusedImportTypes()
    val document = """
        mutation($input: EditSiderealInput!) {
          updateSiderealTarget(input: $input) {
            id
          }
        }
      """
    case class Variables(val input: EditSiderealInput)
    object Variables {
      implicit val input: monocle.Lens[Variables, EditSiderealInput] = monocle.macros.GenLens[Variables](_.input)
      implicit val eqVariables: cats.Eq[Variables] = cats.Eq.fromUniversalEquals
      implicit val showVariables: cats.Show[Variables] = cats.Show.fromToString
      implicit val jsonEncoderVariables: io.circe.Encoder[Variables] = io.circe.generic.semiauto.deriveEncoder[Variables].mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class Data(val updateSiderealTarget: Data.UpdateSiderealTarget)
    object Data {
      case class UpdateSiderealTarget(val id: TargetId)
      object UpdateSiderealTarget {
        implicit val id: monocle.Lens[Data.UpdateSiderealTarget, TargetId] = monocle.macros.GenLens[Data.UpdateSiderealTarget](_.id)
        implicit val eqUpdateSiderealTarget: cats.Eq[Data.UpdateSiderealTarget] = cats.Eq.fromUniversalEquals
        implicit val showUpdateSiderealTarget: cats.Show[Data.UpdateSiderealTarget] = cats.Show.fromToString
        implicit val reuseUpdateSiderealTarget: japgolly.scalajs.react.Reusability[Data.UpdateSiderealTarget] = {
          import japgolly.scalajs.react.Reusability
          japgolly.scalajs.react.Reusability.derive
        }
        implicit val jsonDecoderUpdateSiderealTarget: io.circe.Decoder[Data.UpdateSiderealTarget] = io.circe.generic.semiauto.deriveDecoder[Data.UpdateSiderealTarget]
      }
      implicit val updateSiderealTarget: monocle.Lens[Data, Data.UpdateSiderealTarget] = monocle.macros.GenLens[Data](_.updateSiderealTarget)
      implicit val eqData: cats.Eq[Data] = cats.Eq.fromUniversalEquals
      implicit val showData: cats.Show[Data] = cats.Show.fromToString
      implicit val reuseData: japgolly.scalajs.react.Reusability[Data] = {
        import japgolly.scalajs.react.Reusability
        japgolly.scalajs.react.Reusability.derive
      }
      implicit val jsonDecoderData: io.circe.Decoder[Data] = io.circe.generic.semiauto.deriveDecoder[Data]
    }
    val varEncoder: io.circe.Encoder[Variables] = Variables.jsonEncoderVariables
    val dataDecoder: io.circe.Decoder[Data] = Data.jsonDecoderData
    def execute[F[_]](input: EditSiderealInput)(implicit client: clue.TransactionalClient[F, ObservationDB]) = client.request(this)(Variables(input))
  }
  // format: on
  /* END: Generated by clue. Will be replaced when regenerating. */

  case class UndoView(
    id:           Target.Id,
    view:         View[TargetResult],
    setter:       Undoer.Setter[IO, TargetResult]
  )(implicit ctx: AppContextIO) {
    private val undoableView = UndoableView(view, setter)

    def apply[A](
      modelGet:  TargetResult => A,
      modelMod:  (A => A) => TargetResult => TargetResult,
      remoteSet: A => EditSiderealInput => EditSiderealInput
    ): View[A] =
      undoableView.apply(
        modelGet,
        modelMod,
        value => TargetMutation.execute(remoteSet(value)(EditSiderealInput(id))).void
      )

    def apply[A](
      modelLens: Lens[TargetResult, A],
      remoteSet: A => EditSiderealInput => EditSiderealInput
    ): View[A] = apply(modelLens.get, modelLens.modify, remoteSet)
  }

  object UpdateSiderealTracking {
    def catalogId(cid: Option[CatalogId]): Endo[EditSiderealInput] =
      EditSiderealInput.catalogId.set(
        cid.map(cid => CatalogIdInput(cid.catalog, cid.id.value)).orUnassign
      )

    def epoch(epoch: Option[Epoch]): Endo[EditSiderealInput] =
      EditSiderealInput.epoch.set(epoch.map(Epoch.fromString.reverseGet).orUnassign)

    def ra(ra: Option[RightAscension]): Endo[EditSiderealInput] =
      EditSiderealInput.ra.set(
        ra.map(r => RightAscensionInput(microarcseconds = r.toAngle.toMicroarcseconds.assign))
          .orUnassign
      )

    def dec(dec: Option[Declination]): Endo[EditSiderealInput] =
      EditSiderealInput.dec.set(
        dec
          .map(d => DeclinationInput(microarcseconds = d.toAngle.toMicroarcseconds.assign))
          .orUnassign
      )

    def properMotion(
      pm: Option[ProperMotion]
    ): Endo[EditSiderealInput] =
      EditSiderealInput.properMotion.set(
        pm.map(p =>
          ProperMotionInput(
            ra = ProperMotionComponentInput(microarcsecondsPerYear = p.ra.μasy.value.assign),
            dec = ProperMotionComponentInput(microarcsecondsPerYear = p.dec.μasy.value.assign)
          )
        ).orUnassign
      )

    def radialVelocity(
      rv: Option[RadialVelocity]
    ): Endo[EditSiderealInput] =
      EditSiderealInput.radialVelocity.set(
        rv.map(r =>
          RadialVelocityInput(
            metersPerSecond = r.rv.withUnit[CentimetersPerSecond].value.value.assign
          )
        ).orUnassign
      )

    def parallax(p: Option[Parallax]): Endo[EditSiderealInput] =
      EditSiderealInput.parallax.set(
        p.map(p => ParallaxModelInput(microarcseconds = p.μas.value.value.assign)).orUnassign
      )

    /**
     * Updates all the fields of sideral tracking
     */
    def apply(t: SiderealTracking): Endo[EditSiderealInput] =
      catalogId(t.catalogId) >>>
        ra(t.baseCoordinates.ra.some) >>>
        dec(t.baseCoordinates.dec.some) >>>
        epoch(t.epoch.some) >>>
        properMotion(t.properMotion) >>>
        radialVelocity(t.radialVelocity) >>>
        parallax(t.parallax)
  }

  def updateMagnitudes(mags: List[Magnitude]): Endo[EditSiderealInput] =
    EditSiderealInput.magnitudes.set(mags.map(_.toInput).assign)
}
