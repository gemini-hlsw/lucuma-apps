// Copyright (c) 2016-2021 Association of Universities for Research in Astronomy, Inc. (AURA)
// For license information see LICENSE or https://opensource.org/licenses/BSD-3-Clause

package explore.common

import cats.data.NonEmptyList
import cats.effect.IO
import clue.GraphQLOperation
import clue.annotation.GraphQL
import explore.AppCtx
import explore.components.graphql.LiveQueryRenderMod
import explore.data.KeyedIndexedList
import explore.implicits._
import explore.model.ConstraintsSummary
import explore.model.ObsSummaryWithPointingAndConstraints
import explore.model.Pointing
import explore.model.reusability._
import explore.schemas.ObservationDB
import io.circe.refined._
import japgolly.scalajs.react._
import japgolly.scalajs.react.vdom.html_<^._
import lucuma.core.model.Observation
import lucuma.ui.reusability._
import monocle.Getter

object ObsQueries {

  type ObservationList = KeyedIndexedList[Observation.Id, ObsSummaryWithPointingAndConstraints]

  @GraphQL
  trait ProgramObservationsQueryGQL extends GraphQLOperation[ObservationDB] {
    val document = """
      query {
        observations(programId: "p-2", first: 2147483647) {
          nodes {
            id
            observationTarget {
              type: __typename
              ... on Target {
                targetId: id
                targetName: name
              }
              ... on Asterism {
                asterismId: id
                asterismName: name
              }
            }
            constraintSet {
              id
              name
              imageQuality
              cloudExtinction
              skyBackground
              waterVapor
            }
          }
        }
      }
    """

    object Data {
      object Observations {
        object Nodes {
          type ConstraintSet = ConstraintsSummary
        }
      }
    }

  }

  /* BEGIN: Generated by clue. DO NOT remove or edit the following code or this comment. */
  // format: off
  object ProgramObservationsQuery extends GraphQLOperation[ObservationDB] {
    import ObservationDB.Scalars._
    ignoreUnusedImportScalars()
    import ObservationDB.Enums._
    ignoreUnusedImportEnums()
    import ObservationDB.Types._
    ignoreUnusedImportTypes()
    val document = """
        query {
          observations(programId: "p-2", first: 2147483647) {
            nodes {
              id
              observationTarget {
                type: __typename
                ... on Target {
                  targetId: id
                  targetName: name
                }
                ... on Asterism {
                  asterismId: id
                  asterismName: name
                }
              }
              constraintSet {
                id
                name
                imageQuality
                cloudExtinction
                skyBackground
                waterVapor
              }
            }
          }
        }
      """
    object Data {
      object Observations {
        object Nodes {
          type ConstraintSet = ConstraintsSummary
          sealed trait ObservationTarget
          object ObservationTarget {
            case class Target(val targetId: TargetId, val targetName: NonEmptyString) extends ObservationTarget()
            object Target {
              implicit val targetId: monocle.Lens[Data.Observations.Nodes.ObservationTarget.Target, TargetId] = monocle.macros.GenLens[Data.Observations.Nodes.ObservationTarget.Target](_.targetId)
              implicit val targetName: monocle.Lens[Data.Observations.Nodes.ObservationTarget.Target, NonEmptyString] = monocle.macros.GenLens[Data.Observations.Nodes.ObservationTarget.Target](_.targetName)
              implicit val eqTarget: cats.Eq[Data.Observations.Nodes.ObservationTarget.Target] = cats.Eq.fromUniversalEquals
              implicit val showTarget: cats.Show[Data.Observations.Nodes.ObservationTarget.Target] = cats.Show.fromToString
              implicit val reuseTarget: japgolly.scalajs.react.Reusability[Data.Observations.Nodes.ObservationTarget.Target] = {
                import japgolly.scalajs.react.Reusability
                japgolly.scalajs.react.Reusability.derive
              }
              implicit val jsonDecoderTarget: io.circe.Decoder[Data.Observations.Nodes.ObservationTarget.Target] = io.circe.generic.semiauto.deriveDecoder[Data.Observations.Nodes.ObservationTarget.Target]
            }
            case class Asterism(val asterismId: AsterismId, val asterismName: Option[NonEmptyString] = None) extends ObservationTarget()
            object Asterism {
              implicit val asterismId: monocle.Lens[Data.Observations.Nodes.ObservationTarget.Asterism, AsterismId] = monocle.macros.GenLens[Data.Observations.Nodes.ObservationTarget.Asterism](_.asterismId)
              implicit val asterismName: monocle.Lens[Data.Observations.Nodes.ObservationTarget.Asterism, Option[NonEmptyString]] = monocle.macros.GenLens[Data.Observations.Nodes.ObservationTarget.Asterism](_.asterismName)
              implicit val eqAsterism: cats.Eq[Data.Observations.Nodes.ObservationTarget.Asterism] = cats.Eq.fromUniversalEquals
              implicit val showAsterism: cats.Show[Data.Observations.Nodes.ObservationTarget.Asterism] = cats.Show.fromToString
              implicit val reuseAsterism: japgolly.scalajs.react.Reusability[Data.Observations.Nodes.ObservationTarget.Asterism] = {
                import japgolly.scalajs.react.Reusability
                japgolly.scalajs.react.Reusability.derive
              }
              implicit val jsonDecoderAsterism: io.circe.Decoder[Data.Observations.Nodes.ObservationTarget.Asterism] = io.circe.generic.semiauto.deriveDecoder[Data.Observations.Nodes.ObservationTarget.Asterism]
            }
            implicit val eqObservationTarget: cats.Eq[Data.Observations.Nodes.ObservationTarget] = cats.Eq.fromUniversalEquals
            implicit val showObservationTarget: cats.Show[Data.Observations.Nodes.ObservationTarget] = cats.Show.fromToString
            implicit val reuseObservationTarget: japgolly.scalajs.react.Reusability[Data.Observations.Nodes.ObservationTarget] = {
              import japgolly.scalajs.react.Reusability
              japgolly.scalajs.react.Reusability.derive
            }
            implicit protected val jsonConfiguration: io.circe.generic.extras.Configuration = io.circe.generic.extras.Configuration.default.withDiscriminator("type")
            implicit val jsonDecoderObservationTarget: io.circe.Decoder[Data.Observations.Nodes.ObservationTarget] = io.circe.generic.extras.semiauto.deriveConfiguredDecoder[Data.Observations.Nodes.ObservationTarget]
          }
          implicit val id: monocle.Lens[Data.Observations.Nodes, ObservationId] = monocle.macros.GenLens[Data.Observations.Nodes](_.id)
          implicit val observationTarget: monocle.Lens[Data.Observations.Nodes, Option[Data.Observations.Nodes.ObservationTarget]] = monocle.macros.GenLens[Data.Observations.Nodes](_.observationTarget)
          implicit val constraintSet: monocle.Lens[Data.Observations.Nodes, Option[Data.Observations.Nodes.ConstraintSet]] = monocle.macros.GenLens[Data.Observations.Nodes](_.constraintSet)
          implicit val eqNodes: cats.Eq[Data.Observations.Nodes] = cats.Eq.fromUniversalEquals
          implicit val showNodes: cats.Show[Data.Observations.Nodes] = cats.Show.fromToString
          implicit val reuseNodes: japgolly.scalajs.react.Reusability[Data.Observations.Nodes] = {
            import japgolly.scalajs.react.Reusability
            japgolly.scalajs.react.Reusability.derive
          }
          implicit val jsonDecoderNodes: io.circe.Decoder[Data.Observations.Nodes] = io.circe.generic.semiauto.deriveDecoder[Data.Observations.Nodes]
        }
        case class Nodes(val id: ObservationId, val observationTarget: Option[Data.Observations.Nodes.ObservationTarget] = None, val constraintSet: Option[Data.Observations.Nodes.ConstraintSet] = None)
        implicit val nodes: monocle.Lens[Data.Observations, List[Data.Observations.Nodes]] = monocle.macros.GenLens[Data.Observations](_.nodes)
        implicit val eqObservations: cats.Eq[Data.Observations] = cats.Eq.fromUniversalEquals
        implicit val showObservations: cats.Show[Data.Observations] = cats.Show.fromToString
        implicit val reuseObservations: japgolly.scalajs.react.Reusability[Data.Observations] = {
          import japgolly.scalajs.react.Reusability
          japgolly.scalajs.react.Reusability.derive
        }
        implicit val jsonDecoderObservations: io.circe.Decoder[Data.Observations] = io.circe.generic.semiauto.deriveDecoder[Data.Observations]
      }
      case class Observations(val nodes: List[Data.Observations.Nodes])
      implicit val observations: monocle.Lens[Data, Data.Observations] = monocle.macros.GenLens[Data](_.observations)
      implicit val eqData: cats.Eq[Data] = cats.Eq.fromUniversalEquals
      implicit val showData: cats.Show[Data] = cats.Show.fromToString
      implicit val reuseData: japgolly.scalajs.react.Reusability[Data] = {
        import japgolly.scalajs.react.Reusability
        japgolly.scalajs.react.Reusability.derive
      }
      implicit val jsonDecoderData: io.circe.Decoder[Data] = io.circe.generic.semiauto.deriveDecoder[Data]
    }
    case class Variables()
    object Variables {
      implicit val eqVariables: cats.Eq[Variables] = cats.Eq.fromUniversalEquals
      implicit val showVariables: cats.Show[Variables] = cats.Show.fromToString
      implicit val jsonEncoderVariables: io.circe.Encoder[Variables] = io.circe.generic.semiauto.deriveEncoder[Variables].mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class Data(val observations: Data.Observations)
    val varEncoder: io.circe.Encoder[Variables] = Variables.jsonEncoderVariables
    val dataDecoder: io.circe.Decoder[Data] = Data.jsonDecoderData
    def query[F[_]]()(implicit client: clue.TransactionalClient[F, ObservationDB]) = client.request(this)(Variables())
  }
  // format: on
  /* END: Generated by clue. Will be replaced when regenerating. */

  private def convertPointing(
    pointing: ProgramObservationsQuery.Data.Observations.Nodes.ObservationTarget
  ): Pointing =
    pointing match {
      case ProgramObservationsQuery.Data.Observations.Nodes.ObservationTarget.Target(id, name)   =>
        Pointing.PointingTarget(id, name)
      case ProgramObservationsQuery.Data.Observations.Nodes.ObservationTarget.Asterism(id, name) =>
        Pointing.PointingAsterism(id, name, Nil)
    }

  private val programObservationsQueryoObservationListGetter
    : Getter[ProgramObservationsQuery.Data, ObservationList] = data =>
    KeyedIndexedList.fromList(
      data.observations.nodes.map(node =>
        ObsSummaryWithPointingAndConstraints(node.id,
                                             node.observationTarget.map(convertPointing),
                                             node.constraintSet
        )
      ),
      ObsSummaryWithPointingAndConstraints.id.get
    )
  implicit class ProgramObservationsQueryDataOps(val self: ProgramObservationsQuery.Data.type)
      extends AnyVal {
    def asObservationList = programObservationsQueryoObservationListGetter
  }

  @GraphQL
  trait ProgramObservationsEditSubscriptionGQL extends GraphQLOperation[ObservationDB] {
    val document = """
      subscription {
        observationEdit(programId:"p-2") {
          id
        }
      }
    """
  }

  /* BEGIN: Generated by clue. DO NOT remove or edit the following code or this comment. */
  // format: off
  object ProgramObservationsEditSubscription extends GraphQLOperation[ObservationDB] {
    import ObservationDB.Scalars._
    ignoreUnusedImportScalars()
    import ObservationDB.Enums._
    ignoreUnusedImportEnums()
    import ObservationDB.Types._
    ignoreUnusedImportTypes()
    val document = """
        subscription {
          observationEdit(programId:"p-2") {
            id
          }
        }
      """
    case class Variables()
    object Variables {
      implicit val eqVariables: cats.Eq[Variables] = cats.Eq.fromUniversalEquals
      implicit val showVariables: cats.Show[Variables] = cats.Show.fromToString
      implicit val jsonEncoderVariables: io.circe.Encoder[Variables] = io.circe.generic.semiauto.deriveEncoder[Variables].mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class Data(val observationEdit: Data.ObservationEdit)
    object Data {
      case class ObservationEdit(val id: Long)
      object ObservationEdit {
        implicit val id: monocle.Lens[Data.ObservationEdit, Long] = monocle.macros.GenLens[Data.ObservationEdit](_.id)
        implicit val eqObservationEdit: cats.Eq[Data.ObservationEdit] = cats.Eq.fromUniversalEquals
        implicit val showObservationEdit: cats.Show[Data.ObservationEdit] = cats.Show.fromToString
        implicit val reuseObservationEdit: japgolly.scalajs.react.Reusability[Data.ObservationEdit] = {
          import japgolly.scalajs.react.Reusability
          japgolly.scalajs.react.Reusability.derive
        }
        implicit val jsonDecoderObservationEdit: io.circe.Decoder[Data.ObservationEdit] = io.circe.generic.semiauto.deriveDecoder[Data.ObservationEdit]
      }
      implicit val observationEdit: monocle.Lens[Data, Data.ObservationEdit] = monocle.macros.GenLens[Data](_.observationEdit)
      implicit val eqData: cats.Eq[Data] = cats.Eq.fromUniversalEquals
      implicit val showData: cats.Show[Data] = cats.Show.fromToString
      implicit val reuseData: japgolly.scalajs.react.Reusability[Data] = {
        import japgolly.scalajs.react.Reusability
        japgolly.scalajs.react.Reusability.derive
      }
      implicit val jsonDecoderData: io.circe.Decoder[Data] = io.circe.generic.semiauto.deriveDecoder[Data]
    }
    val varEncoder: io.circe.Encoder[Variables] = Variables.jsonEncoderVariables
    val dataDecoder: io.circe.Decoder[Data] = Data.jsonDecoderData
    def subscribe[F[_]]()(implicit client: clue.StreamingClient[F, ObservationDB]) = client.subscribe(this)(Variables())
  }
  // format: on
  /* END: Generated by clue. Will be replaced when regenerating. */

  val ObsLiveQuery =
    ScalaFnComponent[View[ObservationList] => VdomNode](render =>
      AppCtx.using { implicit appCtx =>
        LiveQueryRenderMod[ObservationDB, ProgramObservationsQuery.Data, ObservationList](
          ProgramObservationsQuery.query(),
          ProgramObservationsQuery.Data.asObservationList.get,
          NonEmptyList.of(
            ProgramObservationsEditSubscription.subscribe[IO](),
            ConstraintSetObsQueries.ConstraintSetEditSubscription.subscribe[IO]()
          )
        )(render)
      }
    )

  @GraphQL
  trait ProgramCreateObservationGQL extends GraphQLOperation[ObservationDB] {
    val document = """
      mutation($createObservation: CreateObservationInput!) {
        createObservation(input: $createObservation) {
          id
        }
      }
    """
  }

  /* BEGIN: Generated by clue. DO NOT remove or edit the following code or this comment. */
  // format: off
  object ProgramCreateObservation extends GraphQLOperation[ObservationDB] {
    import ObservationDB.Scalars._
    ignoreUnusedImportScalars()
    import ObservationDB.Enums._
    ignoreUnusedImportEnums()
    import ObservationDB.Types._
    ignoreUnusedImportTypes()
    val document = """
        mutation($createObservation: CreateObservationInput!) {
          createObservation(input: $createObservation) {
            id
          }
        }
      """
    case class Variables(val createObservation: CreateObservationInput)
    object Variables {
      implicit val createObservation: monocle.Lens[Variables, CreateObservationInput] = monocle.macros.GenLens[Variables](_.createObservation)
      implicit val eqVariables: cats.Eq[Variables] = cats.Eq.fromUniversalEquals
      implicit val showVariables: cats.Show[Variables] = cats.Show.fromToString
      implicit val jsonEncoderVariables: io.circe.Encoder[Variables] = io.circe.generic.semiauto.deriveEncoder[Variables].mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class Data(val createObservation: Option[Data.CreateObservation] = None)
    object Data {
      case class CreateObservation(val id: ObservationId)
      object CreateObservation {
        implicit val id: monocle.Lens[Data.CreateObservation, ObservationId] = monocle.macros.GenLens[Data.CreateObservation](_.id)
        implicit val eqCreateObservation: cats.Eq[Data.CreateObservation] = cats.Eq.fromUniversalEquals
        implicit val showCreateObservation: cats.Show[Data.CreateObservation] = cats.Show.fromToString
        implicit val reuseCreateObservation: japgolly.scalajs.react.Reusability[Data.CreateObservation] = {
          import japgolly.scalajs.react.Reusability
          japgolly.scalajs.react.Reusability.derive
        }
        implicit val jsonDecoderCreateObservation: io.circe.Decoder[Data.CreateObservation] = io.circe.generic.semiauto.deriveDecoder[Data.CreateObservation]
      }
      implicit val createObservation: monocle.Lens[Data, Option[Data.CreateObservation]] = monocle.macros.GenLens[Data](_.createObservation)
      implicit val eqData: cats.Eq[Data] = cats.Eq.fromUniversalEquals
      implicit val showData: cats.Show[Data] = cats.Show.fromToString
      implicit val reuseData: japgolly.scalajs.react.Reusability[Data] = {
        import japgolly.scalajs.react.Reusability
        japgolly.scalajs.react.Reusability.derive
      }
      implicit val jsonDecoderData: io.circe.Decoder[Data] = io.circe.generic.semiauto.deriveDecoder[Data]
    }
    val varEncoder: io.circe.Encoder[Variables] = Variables.jsonEncoderVariables
    val dataDecoder: io.circe.Decoder[Data] = Data.jsonDecoderData
    def execute[F[_]](createObservation: CreateObservationInput)(implicit client: clue.TransactionalClient[F, ObservationDB]) = client.request(this)(Variables(createObservation))
  }
  // format: on
  /* END: Generated by clue. Will be replaced when regenerating. */

  @GraphQL
  trait ProgramDeleteObservationGQL extends GraphQLOperation[ObservationDB] {
    val document = """
      mutation($oid: ObservationId!) {
        deleteObservation(observationId: $oid) {
          id
        }
      }
    """
  }

  /* BEGIN: Generated by clue. DO NOT remove or edit the following code or this comment. */
  // format: off
  object ProgramDeleteObservation extends GraphQLOperation[ObservationDB] {
    import ObservationDB.Scalars._
    ignoreUnusedImportScalars()
    import ObservationDB.Enums._
    ignoreUnusedImportEnums()
    import ObservationDB.Types._
    ignoreUnusedImportTypes()
    val document = """
        mutation($oid: ObservationId!) {
          deleteObservation(observationId: $oid) {
            id
          }
        }
      """
    case class Variables(val oid: ObservationId)
    object Variables {
      implicit val oid: monocle.Lens[Variables, ObservationId] = monocle.macros.GenLens[Variables](_.oid)
      implicit val eqVariables: cats.Eq[Variables] = cats.Eq.fromUniversalEquals
      implicit val showVariables: cats.Show[Variables] = cats.Show.fromToString
      implicit val jsonEncoderVariables: io.circe.Encoder[Variables] = io.circe.generic.semiauto.deriveEncoder[Variables].mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class Data(val deleteObservation: Data.DeleteObservation)
    object Data {
      case class DeleteObservation(val id: ObservationId)
      object DeleteObservation {
        implicit val id: monocle.Lens[Data.DeleteObservation, ObservationId] = monocle.macros.GenLens[Data.DeleteObservation](_.id)
        implicit val eqDeleteObservation: cats.Eq[Data.DeleteObservation] = cats.Eq.fromUniversalEquals
        implicit val showDeleteObservation: cats.Show[Data.DeleteObservation] = cats.Show.fromToString
        implicit val reuseDeleteObservation: japgolly.scalajs.react.Reusability[Data.DeleteObservation] = {
          import japgolly.scalajs.react.Reusability
          japgolly.scalajs.react.Reusability.derive
        }
        implicit val jsonDecoderDeleteObservation: io.circe.Decoder[Data.DeleteObservation] = io.circe.generic.semiauto.deriveDecoder[Data.DeleteObservation]
      }
      implicit val deleteObservation: monocle.Lens[Data, Data.DeleteObservation] = monocle.macros.GenLens[Data](_.deleteObservation)
      implicit val eqData: cats.Eq[Data] = cats.Eq.fromUniversalEquals
      implicit val showData: cats.Show[Data] = cats.Show.fromToString
      implicit val reuseData: japgolly.scalajs.react.Reusability[Data] = {
        import japgolly.scalajs.react.Reusability
        japgolly.scalajs.react.Reusability.derive
      }
      implicit val jsonDecoderData: io.circe.Decoder[Data] = io.circe.generic.semiauto.deriveDecoder[Data]
    }
    val varEncoder: io.circe.Encoder[Variables] = Variables.jsonEncoderVariables
    val dataDecoder: io.circe.Decoder[Data] = Data.jsonDecoderData
    def execute[F[_]](oid: ObservationId)(implicit client: clue.TransactionalClient[F, ObservationDB]) = client.request(this)(Variables(oid))
  }
  // format: on
  /* END: Generated by clue. Will be replaced when regenerating. */

  @GraphQL
  trait ProgramUndeleteObservationGQL extends GraphQLOperation[ObservationDB] {
    val document = """
      mutation($oid: ObservationId!) {
        undeleteObservation(observationId: $oid) {
          id
        }
      }
    """
  }

  /* BEGIN: Generated by clue. DO NOT remove or edit the following code or this comment. */
  // format: off
  object ProgramUndeleteObservation extends GraphQLOperation[ObservationDB] {
    import ObservationDB.Scalars._
    ignoreUnusedImportScalars()
    import ObservationDB.Enums._
    ignoreUnusedImportEnums()
    import ObservationDB.Types._
    ignoreUnusedImportTypes()
    val document = """
        mutation($oid: ObservationId!) {
          undeleteObservation(observationId: $oid) {
            id
          }
        }
      """
    case class Variables(val oid: ObservationId)
    object Variables {
      implicit val oid: monocle.Lens[Variables, ObservationId] = monocle.macros.GenLens[Variables](_.oid)
      implicit val eqVariables: cats.Eq[Variables] = cats.Eq.fromUniversalEquals
      implicit val showVariables: cats.Show[Variables] = cats.Show.fromToString
      implicit val jsonEncoderVariables: io.circe.Encoder[Variables] = io.circe.generic.semiauto.deriveEncoder[Variables].mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class Data(val undeleteObservation: Data.UndeleteObservation)
    object Data {
      case class UndeleteObservation(val id: ObservationId)
      object UndeleteObservation {
        implicit val id: monocle.Lens[Data.UndeleteObservation, ObservationId] = monocle.macros.GenLens[Data.UndeleteObservation](_.id)
        implicit val eqUndeleteObservation: cats.Eq[Data.UndeleteObservation] = cats.Eq.fromUniversalEquals
        implicit val showUndeleteObservation: cats.Show[Data.UndeleteObservation] = cats.Show.fromToString
        implicit val reuseUndeleteObservation: japgolly.scalajs.react.Reusability[Data.UndeleteObservation] = {
          import japgolly.scalajs.react.Reusability
          japgolly.scalajs.react.Reusability.derive
        }
        implicit val jsonDecoderUndeleteObservation: io.circe.Decoder[Data.UndeleteObservation] = io.circe.generic.semiauto.deriveDecoder[Data.UndeleteObservation]
      }
      implicit val undeleteObservation: monocle.Lens[Data, Data.UndeleteObservation] = monocle.macros.GenLens[Data](_.undeleteObservation)
      implicit val eqData: cats.Eq[Data] = cats.Eq.fromUniversalEquals
      implicit val showData: cats.Show[Data] = cats.Show.fromToString
      implicit val reuseData: japgolly.scalajs.react.Reusability[Data] = {
        import japgolly.scalajs.react.Reusability
        japgolly.scalajs.react.Reusability.derive
      }
      implicit val jsonDecoderData: io.circe.Decoder[Data] = io.circe.generic.semiauto.deriveDecoder[Data]
    }
    val varEncoder: io.circe.Encoder[Variables] = Variables.jsonEncoderVariables
    val dataDecoder: io.circe.Decoder[Data] = Data.jsonDecoderData
    def execute[F[_]](oid: ObservationId)(implicit client: clue.TransactionalClient[F, ObservationDB]) = client.request(this)(Variables(oid))
  }
  // format: on
  /* END: Generated by clue. Will be replaced when regenerating. */
}
